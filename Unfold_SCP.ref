/****************************************************************************
   
            ГЛАВНЫЙ МОДУЛЬ MSCP-A
            Содержит функцию, реализующую основной шаг суперкомпиляции:
            UnfoldMain
            Формат ее:
            (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]
   
****************************************************************************/

$EXTERN prefal, c-prefal;
/* из модуля basics.ref */
$EXTERN IfASubMultiSet, IfIncluded, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,
    SubtractEl,InsertInMultiSet,MergeSets,SetMinus,FindNode;
/* из модуля basics.ref */
$EXTERN GenPath, DeleteNode, InsertNode, Collapse,SaveDriveMarker,Substitute, Map,
    DeleteMarkedEqs,GetParList, SubstInversion;
/* из модуля basics.ref */
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, RenewIndices, FreshIndex, CurrentIndex, 
    MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* из модуля drive.ref */
$EXTERN ClashLeft,GenerateNextLevel,PostProcessPRTC,FormatStack,AssignTimeStamps, Drive, CheckNarrowingsScreening;
/* из модуля AnalyzeFunDef.ref */
$EXTERN AssignFunctionFeatures;
/* из модуля stack.ref */
$EXTERN YieldDecomposition;
/* из модуля WordEquations.ref */
$EXTERN IfEqIsImplied, ImplyNEqsNew,NormalizeInequalityBlock;
/* из модуля WordEqsCases.ref */
$EXTERN ProcessLinearInequality, ImplyNEqs;
/* из модуля residual.ref */
$EXTERN YieldProgramGeneration;
/* из модуля generalize.ref */
$EXTERN CheckNode4Generalization,CheckNode4Equivalence,NegativeCleaning, HomeomorphicEmb; /* последняя для теста. */
/* из модуля accessMSCP.ref */
$EXTERN AddNewLines, GetNodeStatus, PutNodeStatus, GetNodeName, PutNodeName, GetNodeRestrictions, PutNodeRestrictions, GetNodeConfig, PutNodeConfig,
    GetNodeStack, PutNodeStack, GetNodeEqs, PutNodeEqs, PutNodeNewEqs, GetNodeNewEqs, ReplaceNodeNewEqs,GetNodeLets, PutNodeLets, GetNodeChildren, PutNodeChildren,
    GenerateNewNode, GetNodeFullConfig, GetStackTop, DeleteNodeActiveData, GetNodeConfFromStack, PutNodeNewEqsToOld,
    GenerateFreshPRTC, ReplacePRTCAllEqs, NullifyNodeEqs, ReplaceNodeGenEqs, GetNodeGenericEqs, ReplaceNodeNegEqs,
    FormatPRTCToPrint, FormatTreeToPrint,RenameStackTop, PutNodeNegEqs, GetNodeNegEqs, SubstituteInNegative;

$ENTRY Go {
    , <Arg 1> : e.input0
    , <Arg 2> : e.output0
    , <GetInputFile ()e.input0> : (e.folder)e.input
    , <GetOutputFile (e.folder)(e.input)e.output0> : e.output
        =
        <Open 'w' 1 'mscplog'<SubdirSign>'trace_scp'>
        <Open 'w' 2 'mscplog'<SubdirSign>'generalizations'>
        <Open 'a' 3 'mscptest'<SubdirSign>'terms.txt'>
        <Collapse <TimeElapsed 0>>
        <RenewAllIndices>
        <c-prefal 
            (e.output)
            (
                (EXTERN )
                <TransformIntoRefal
                    <PredMainStep 
                        <TransformEncoding ()() <prefal e.input>>
                    >
                (Comment '/* This file is generated by MSCP at '<Time>'.*/')
               (Comment '/* Elapsed time of embeddings is '<FormatOut <Dg 'emb_time'>>'.*/') 
                (Comment '/* Elapsed time of generalizations is '<FormatOut <Dg 'mgu_time'>>'.*/') 
                >
            )<AAA>
            ('/verbose')
        >
        <Close 1><Close 2><Close 3>;
}

/* Преобразует натуральное число в формат <число>.<число>. */
FormatOut {
    s.x = <Symb <Div s.x 1000>>'.'<Symb <Mod s.x 1000>>;
}

$ENTRY Delcomm {
     = ;
    (Comment e.1) e.2 = <Delcomm e.2>;
    (t.other e.1) e.2 = (t.other <Delcomm e.1>)<Delcomm e.2>;
}

$ENTRY SubdirSign {
*  Windows
    = '\\';
* Linux
    = '/';
*  Macintosh (Apple)
    = ':' ; 
}

/*
    Функция получения имени входного файла.
   [string] => [string].ref 
*/
GetInputFile {
/* 0. Выделяем путь до файла. */
    (e.path)e.1 e.2 e.3
    , <SubdirSign> : e.2 
        = <GetInputFile (e.path e.1 e.2) e.3>;
/* 1. Если файл имеет расширение ref, данного файла в папке запуска нет, и путь до него пуст, проверяем его наличие в подпапке test. */
    (/* EMPTY */)e.1'.ref'
    , <ExistFile e.1'.ref'> : False
    , <ExistFile 'tests'<SubdirSign>e.1'.ref'> : True 
        = ('tests'<SubdirSign>)'tests'<SubdirSign> e.1'.ref';
/* 2. Если имя в параметрах запуска в командной строке отсутствует, файлом по умолчанию считаем test.ref */
    (e.path) = (e.path)e.path'test.ref';
/* 3. Если имя задано с расширением ref -- оставляем его как есть. */
    (e.path)e.1'.ref' = (e.path)e.path e.1'.ref';
/* 4. Если имя задано с другим расширением -- удаляем это расширение и приписываем расширение ref. */
    (e.path)e.1'.'e.2 = (e.path)e.path e.1'.ref';
/* 5. Если имя задано без расширения -- приписываем расширение ref. */
    (e.path)e.1 = (e.path)e.path e.1'.ref';
}

/* Функция получения имени выходного файла (файла остаточной программы). */
GetOutputFile {
/* 1. Если имя в параметрах запуска в командной строке отсутствует, остаточная программа помещается в файл rsd_[имя входного файла]. */
    (e.path)(e.path e.1)  = e.path'rsd_'e.1;
/* 2. Если имя задано с расширением ref -- оставляем его как есть. */
    (e.path)(e.1) e.2'.ref' = e.2'.ref';
/* 3. Если имя задано с другим расширением -- удаляем это расширение и приписываем расширение ref. */
    (e.path)(e.1)e.2'.'e.3 = e.2'.ref';
/* 4. Если имя задано без расширения -- приписываем расширение ref. */
    (e.path)(e.1)e.2 = e.2'.ref';
}

/*
   $ENTRY Go {= <Open 'w' 1 'trace_scp'><Put 1 <HomeomorphicEmb ((par e 13 )'II'(par e 269 )'II'(par e 269 )(call (Mul1 14 )(args (arg ('*'(par e 269 ))'II'(par e 269 )))))
                (par e 13 )'III'(par e 542 )'III'(par e 542 )'III'(par e 542 )(call (Mul1 15 )(args (arg ('*'(par e 542 ))'III'(par e 542 ))))>><Close 1>;
            }
   
/*
   Функция, обнуляющая все индексы.
   varl_ind - индексы переменных в стеке;
   pari_ind - индексы параметров типа i;
   wevali_ind - индексы строковых переменных типа i;
   time_stamp - временные метки вызовов функций (для отношения Турчина); 
   emb_time - общее время, затраченное на проверку вложений;
   mgu_time - общее время, затраченное на обобщения;
   eqsolv_time - общее время, затраченное на решение уравнений в словах.
*/
$ENTRY RenewAllIndices {
    = <Map RenewIndices 
        varl_ind time_stamp pare_ind part_ind pars_ind
        wevalt_ind wevale_ind wevals_ind emb_time mgu_time eqsolv_time Subtree prtc_ind
    >
    <Br 'Changes=F'><Br 'DriveType=C'>;
}

ProutByStrings {
    /* EMPTY */ = /* EMPTY */;
    t.1 e.1 = <Prout t.1><Prout><ProutByStrings e.1>;
}

/*******************************  Функции перекодировки **************************************/

/* Перевод предложений остаточной функции из промежуточного представления в представление prefal. */
TransformIntoRefal {
    /* EMPTY */ = /* EMPTY */;
    (Comment e.1) e.other = (Comment e.1)<TransformIntoRefal e.other>;
    ((ENTRY) t.FunctionName e.Definitions) e.other
        = ((ENTRY) (Go) <TransformDefinition e.Definitions>) <TransformIntoRefal e.other>;
    ((LOCAL) ((t.FunctionName (e.Set)) t.Number) e.Definitions) e.other
        = ((LOCAL) (<Implode <Explode t.FunctionName>'_'<SymbSet e.Set>'_'<Symb t.Number>>)
        <TransformDefinition e.Definitions>)<TransformIntoRefal e.other>;
    ((LOCAL) (t.FunctionName t.Number) e.Definitions) e.other
        = ((LOCAL) (<Implode <Explode t.FunctionName>'_'<Symb t.Number>>)
        <TransformDefinition e.Definitions>)<TransformIntoRefal e.other>;
}

/* Перевод промежуточного представления определения функции в представление prefal. */
TransformDefinition {
    /* EMPTY */ = /* EMPTY */;
    ((e.Pars)'='(e.RightSide)) e.Other
        = ((<TransformExpressionToPrefal e.Pars>)'='(Expression <TransformExpressionToPrefal e.RightSide>))
        <TransformDefinition e.Other>;
}

/* Перевод выражения в представление prefal. */
TransformExpressionToPrefal {
    /* EMPTY */ = /* EMPTY */; 
    (Variable s.Sym t.name) e.other
    , <Type t.name>: 'N' 
        = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other
    , <Type t.name>: 'D' 
        = (Variable <Explode s.Sym> <Implode <Symb t.name>>)<TransformExpressionToPrefal e.other>;
    (Variable s.Sym t.name) e.other
        = (Variable <Explode s.Sym> t.name)<TransformExpressionToPrefal e.other>;
    s.Sym e.other
    , <Type s.Sym> : 
        {
        'W' e.1
            = (Word s.Sym)<TransformExpressionToPrefal e.other>;
        'N' e.1
            = (MacroDigit s.Sym)<TransformExpressionToPrefal e.other>;
        e.Z = s.Sym <TransformExpressionToPrefal e.other>;
        };
    (MacroDigit e.1) e.2 = (MacroDigit e.1)<TransformExpressionToPrefal e.2>;
    (Bracket' 'e.1) e.2 = (Bracket <TransformExpressionToPrefal e.1>)<TransformExpressionToPrefal e.2>;
    (Call ((t.fname (e.Set)) s.number) e.arg) e.other 
        = (Call <Implode <Explode t.fname>'_'<SymbSet e.Set>'_'<Symb s.number>> <TransformExpressionToPrefal e.arg>)<TransformExpressionToPrefal e.other>;
    (Call (t.fname s.number) e.arg) e.other = (Call <Implode <Explode t.fname>'_'<Symb s.number>> <TransformExpressionToPrefal e.arg>)<TransformExpressionToPrefal e.other>;
    (Condition (Expression e.1)(Pattern e.2)) e.Rest
        = (Condition (Expression <TransformExpressionToPrefal e.1>)(Pattern e.2))<TransformExpressionToPrefal e.Rest>;
}

SymbSet {
    /* EMPTY */ = /* EMPTY */;
    s.Num1 e.Other = <Symb s.Num1><SymbSet e.Other>;
}

/*
    Базовая функция перекодировки из формата prefal во внутренний формат MSCP. 
   ((t.fname((e.LHS)e.RHS)^*)^*)((t.fname((e.LHS)e.RHS)^*)^*)e.ExpressionToTransform =>
   ((t.fname((e.LHS)e.RHS)^*)^*)[Stack]
*/
TransformEncoding {
/* 1. Перекодировка завершена. Считаем, что входная точка лишь одна, и она помещается в вершину стека. */
    (e.functions)(e.entrypoints) = (e.functions)(((assign (var l (0)) (e.entrypoints)) ));
/* 2. Игнорируем информацию о внешних функциях. */
    (e.functions)(e.entrypoints)(EXTERN e.ext) e.rest  = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/* 3. Игнорируем комментарии вне определений функций. */
    (e.functions)(e.entrypoints)(Comment e.ext) e.rest = <TransformEncoding (e.functions)(e.entrypoints) e.rest>;
/* 4. Входную точку (единственную) запоминаем отдельно. */
    (e.functions)(e.entrypoints)((ENTRY) t.fname e.CommentBefore ((e.lhs)'=' (Expression e.rhs))e.CommentAfter) e.rest
    , <Br 'entrypoint='<ConvertExpr Entry e.lhs>> : e.1
        = <TransformEncoding (e.functions)(e.entrypoints <ConvertExpr Entry e.rhs>) e.rest>;
/* 5. Перекодировка определения функции. */
    (e.functions)(e.entrypoints)((LOCAL) (e.fname) e.definition) e.rest
        = <TransformEncoding (e.functions (e.fname (Sents <ConvertDef e.definition>)))(e.entrypoints) e.rest>;

}

/* Функция перевода кодировки для предложений в определении функции из формата prefal во внутренний язык MSCP. */
ConvertDef {
    /* EMPTY */ = /* EMPTY */;
/* Комментарии в определениях функций удаляются. */
    (Comment e.x) e.rest = <ConvertDef e.rest>;
/* Левые и правые части помещаются за одни скобки и каждая перекодируется. */
    ((e.lhs) '=' (Expression e.rhs)) e.rest = ((<ConvertExpr Regular e.lhs>) <ConvertExpr Regular e.rhs>) <ConvertDef e.rest>;
}

/* Функция перевода кодировки для выражения в определении функции из формата prefal во внутренний язык MSCP. */
ConvertExpr {
    s.Mode (Comment e.x) e.rest = <ConvertExpr s.Mode e.rest>;
    s.Mode = /* EMPTY */;
/* 1. перекодировка констант в себя. */
    s.Mode s.1 e.1 = s.1 <ConvertExpr s.Mode e.1>;
/* 2. слово перекодируется просто в себя. */
    s.Mode (Word e.1) e.2 = <ConvertExpr s.Mode e.1> <ConvertExpr s.Mode e.2>;
/* 3. перекодировка структурных скобок. */
    s.Mode (Bracket e.1) e.2 = ('*'<ConvertExpr s.Mode e.1>) <ConvertExpr s.Mode e.2>;
/* 4. перекодировка переменных разных типов. */
    s.Mode (Variable t.type t.name) e.2
    , s.Mode :
        {Regular = (var <Implode t.type> t.name) <ConvertExpr s.Mode e.2>; 
        Entry = (par <Implode t.type> t.name) <ConvertExpr s.Mode e.2>;
        };
/* 5. число перекодируется просто в себя. */
    s.Mode (MacroDigit s.digit)  e.2 = s.digit <ConvertExpr s.Mode e.2>; 
/* 6. перекодировка вызова функции. */
    s.Mode (Call s.fname e.arg) e.rest
        = (call s.fname (args (arg <ConvertExpr s.Mode e.arg>))) <ConvertExpr s.Mode e.rest>; 
/* 7. в остальных случаях - сообщение об ошибке. */
    e.z = <Prout 'The input language contains non-basic primitives.'> <Recogn_Impossible>;
}


/*
   Декодирование результата работы UnfoldMain перед его выдачей;
   символ * после открывающей скобки удаляется.
*/

/*
    Decode {
	= ;
	s.1 e.1 = s.1 <Decode e.1>;
	('*' e.1) e.2 = (<Decode e.1>) <Decode e.2>;
   } 
*/

/*******************************  Закончились функции перекодировки **************************************/


/*
	Производим декомпозицию входного вызова и запускаем главную функцию.
	(e.Program)(((assign (var l t.n ) (e.expr)))) => (Node Finished (e.NodeData)(Children [Node]^*))
*/
PredMainStep {
    (e.Program)(((assign (var l t.n )(e.expr))))
    , <YieldDecomposition ((assign (var l t.n )(<AssignTimeStamps e.expr>)))> : e.Stack
    , <GetNodeConfFromStack <PutNodeStack <GenerateNewNode (0)> e.Stack>> : t.Root 
        = <YieldProgramGeneration 
            <UnfoldMain 
                (<AssignFunctionFeatures e.Program>) 
                t.Root
                ((0))
                t.Root
            >
        >;
}

/***********************************************************************************************************
     Основной шаг развертки. 
     <UnfoldMain (e.Program)[NodeX]([PathOfX])[FullTree]> ==> [FullTree]
     [Node]::= (Node t.Status t.Name ((e.Restrictions)(e.ConfigEquations)(e.LetExpressions)(e.FullConfig)(e.Stack))
     (Children [Node]^*))
     t.Status::= Driven | Undriven | Ready | Finished | (Looped e.NodeName)|ReadyForGenCheck
     [PathOfX]:: = ((0) [NodeName]^*)
     [FullTree]::= (Node t.Status (0) (e.NodeData)(Children [Node]^*))
************************************************************************************************************/


UnfoldMain {
/* 1. Корневая вершина не имеет потомков с непрогнанными конфигурациями. */
    t.Program (Node Finished t.RootName e.ConfNode)(t.RootName) (Node t.Status t.RootName e.Config) 
        = (Node Finished t.RootName e.ConfNode);
/* 2. противоречие в корневой конфигурации. */
    t.Program (Node Driven (e.RootName) (e.CurrConf) (Children )) (t.RootName) (Node t.Status t.RootName e.Config) 
        = Contradiction;
/* 3. противоречие в некорневой конфигурации - переходим к ее родителю. */
    t.Program t.Node (e.Path t.NodeName) t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : 
        = 
        <UnfoldMain 
            t.Program <FindNode (e.Path) <DeleteNode (e.Path t.NodeName) t.Tree>>
            (e.Path)<DeleteNode (e.Path t.NodeName) t.Tree>
        >;
/* 4. завершение вычислений в некорневой конфигурации - переходим к ее родителю. */
    t.Program t.Node t.Path t.Tree
    , <GetNodeStatus t.Node> : Finished
    , <FindAncestorPath t.Path <GetNodeName t.Node>> : t.NewPath
        = <UnfoldMain 
            t.Program <FindNode t.NewPath t.Tree>
            t.NewPath t.Tree
        >;
/* 5. если узел прогнан и имеет единственный дочерний узел с вытолкнутым вызовом, заменяем его данными данные узла. */
    t.Program t.Node (e.Path) t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : e.1 (e.PushChild ((Push)e.OtherConf)) e.2
    , <GetNodeRestrictions t.Node> : e.Restrictions
    , <GetNodeStack (e.PushChild ((Push)e.OtherConf))> : e.NewStack
    , <PutNodeStatus t.Node Ready> : t.Node1
    , <GetNodeConfFromStack <PutNodeStack t.Node1 e.NewStack>> : t.Node2
    , <PutNodeChildren t.Node2 > : t.ProcessedNode
        = 
        <UnfoldMain
            t.Program 
            <PrintIfTracing t.ProcessedNode>
            (e.Path) 
            <InsertNode t.ProcessedNode (e.Path)t.Tree>
        >;
/* 5а. если узел прогнан и имеет единственный дочерний узел, причем транзитный, его не обобщаем	 
*/
/*
    	t.Program 
        (Node ReadyForGenCheck t.Nodename ((e.Restrictions) e.Conf) 
            (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
        )
        (e.Path) t.Tree 
		= 
		<UnfoldMain
			t.Program 
				<PrintIfTracing (Node Driven t.Nodename ((e.Restrictions) e.Conf)
                                                        (Children (Node Undriven t.ChildNode ((Always) e.NewConf))))>
				(e.Path) 
				<InsertNode (Node Driven t.Nodename ((e.Restrictions) e.Conf) 
                                    (Children (Node Undriven t.ChildNode ((Always) e.NewConf)))
                                    )(e.Path)t.Tree
                                >
		>; 
*/

/* 6. если узел прогнан или оказалось, что его конфигурация повторна):
	a) вставляем прогонку в дерево путей,
	и
	б) ищем ближайший непрогнанный узел.
*/
    t.Program t.Node (e.Path) t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Driven (Looped)> : True
        = 
        <UnfoldMain
            t.Program 
            <ChooseUndrivenNode 
                    t.Node
                    (e.Path) 
                    <InsertNode t.Node(e.Path)t.Tree>
            >
        >;
/* 7. Проверяем, имеются ли конфигурации, повторяющие данную. */
/*
    	t.Program (Node Undriven t.Name (e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree 
		= <UnfoldMain t.Program 
                        (Node 
                            <CheckNode4Equivalence 
                                (e.FullConf)
                                (e.Path)
                                t.Tree
                            > 
                            t.Name (e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >; 
*/
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : Undriven
    , <PutNodeStatus t.Node Ready> : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            t.ProcessedNode
            (e.Path t.Last) t.Tree
        >;
/* 8. Если узел транзитный, мы его не обобщаем. */
/*
    	t.Program (Node ReadyForGenCheck t.Name ((Always)e.Conf (e.FullConf)(e.Stack))
		)(e.Path t.Last) t.Tree 
		= <UnfoldMain t.Program 
                        (Node 
                            Ready 
                            t.Name ((Always)e.Conf (e.FullConf)  (e.Stack))
                        )
                    (e.Path t.Last) t.Tree
                    >;
*/
/* 9. Проверяем, является ли узел _после_ прогонки кандидатом на обобщение. */
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : ReadyForGenCheck
    , <GetNodeName t.Node> : t.Name
    , <GetNodeConfig t.Node> : e.FullConf
    , <GetNodeEqs t.Node> : e.Eqs
    , <GetNodeStack t.Node> : e.Stack
    , e.Stack : ((assign t.var ((call t.funname e.Arg)))e.ThisLevel) e.OtherLevels
    , <GetFunRecursionType t.funname t.Program> : s.Flag
    , <PutNodeStatus t.Node <CheckNode4Generalization t.Name s.Flag (e.Eqs)(e.FullConf)(e.Stack)(e.Path)t.Tree>> : t.ProcessedNode
        = <UnfoldMain t.Program 
            t.ProcessedNode
            (e.Path t.Last) t.Tree
        >;
/* 10а. Узел обобщается --- вариант обобщения снизу (верхняя конфигурация есть MGU для нижней с точностью до переименовки).
   Здесь может быть как просто вложение, так и обобщение по рестрикциям (уравнения или неравенства). 
*/
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : 
            (Generalized (e.NodeName) 
                (Looped To t.AncestorName With e.Subs and (Generic e.GenGenEqs)(Negative e.NegGenEqs))(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children))
    , <FindNode (<GenPath t.AncestorName>) t.Tree> : t.AncestorNode
    , <GetNodeGenericEqs t.AncestorNode> : e.OldGenEqs
    , <GetNodeNegEqs t.AncestorNode> : e.OldNegEqs
    , <DeleteMarkedEqs ('S')<GetNodeNewEqs t.AncestorNode>> : e.OldNewEqs
    , <Substitute (<Substitute (<CutLetData e.Assignments>)e.Subs>)e.OldGenEqs e.OldNewEqs> : e.EqsSubstituted
    , <SubstituteInNegative (<Substitute (<CutLetData e.Assignments>)e.Subs>)e.OldNegEqs> : e.NEqsSubstituted
    , <SubstituteInNegative (<CutLetData e.Assignments>) e.NegGenEqs> : e.ProcNegEqs
    , <GetPreservedEqs 
        (e.OldGenEqs e.OldNewEqs)(e.EqsSubstituted)
        (e.GenGenEqs <GetNodeGenericEqs t.Node><GetNodeNewEqs t.Node>)
    > : e.CommonEqs
    , <ImplyNEqsNew 
        (<GetNodeNegEqs t.Node> e.ProcNegEqs)
        (<Zip (e.NEqsSubstituted)(e.OldNegEqs)>)
    > : s.Log e.CommonNeqs0
    , <SubstituteInNegative (<SubstInversion e.Subs>) e.CommonNeqs0> : e.CommonNeqs
    , <Putout 2 '  Checking embedding:'>
    <Putout 2 <AddNewLines <GetNodeNegEqs t.Node> e.ProcNegEqs>>
    <Putout 2 <AddNewLines e.NEqsSubstituted>> : /* */
    , <LogAnd <EquivalentEqSet (e.OldGenEqs e.OldNewEqs) e.CommonEqs> s.Log> :
        {'T'
        , <NullifyNodeEqs <DeleteNodeActiveData t.Node>> : t.DrivenNode
        , <GetNodeConfFromStack <PutNodeStack
            <PutNodeStatus <GenerateNewNode (e.NodeName 0)> (Looped To t.AncestorName With e.Subs)>
            e.GenStack>> : t.NewNode
        , <PutNodeChildren <PutNodeStatus t.DrivenNode Driven> t.NewNode e.Children> : t.Node3
        , <PutNodeLets t.Node3 (Let e.Assignments In (e.GenFullConf))> : t.ProcessedNode
		= <Putout 1><Putout 1 '  Equations are preserved:' <AddNewLines e.CommonEqs>>
                  <Putout 2><Putout 2 '  Equations are preserved:' <AddNewLines e.CommonEqs>>
                  <Putout 1><Putout 1 '  Inequalities are preserved:' <AddNewLines e.CommonNeqs>>
                  <Putout 2><Putout 2 '  Inequalities are preserved:' <AddNewLines e.CommonNeqs>>
                    <UnfoldMain t.Program 
                    <PrintIfTracing t.ProcessedNode>
                    (e.Path t.Last) t.Tree
                >;
        'F'
        , <PutNodeChildren 
                <ReplaceNodeNewEqs
                <PutNodeStatus 
                    <ReplaceNodeNegEqs 
                        <ReplaceNodeGenEqs t.AncestorNode e.CommonEqs <Substitute (<SubstInversion e.Subs>)e.GenGenEqs>> 
                        <NegativeCleaning e.CommonNeqs e.NegGenEqs>
                    > 
                Undriven>
                <MarkAllEqs ('S')e.OldNewEqs>>
        > : t.ProcessedAncNode
            = <Putout 1><Putout 1 '  Equations are cut:'<AddNewLines e.OldGenEqs e.OldNewEqs>>
                <Putout 1 '   to' <AddNewLines e.CommonEqs e.GenGenEqs>>
            <Putout 1><Putout 1 '  Inequalities are cut:'<AddNewLines e.OldNegEqs>>
                <Putout 1 '  to'<AddNewLines e.CommonNeqs e.NegGenEqs>>
            <Putout 2><Putout 2 '  Equations are cut:'<AddNewLines e.OldGenEqs e.OldNewEqs>>
                <Putout 2 '  to'<AddNewLines e.CommonEqs e.GenGenEqs>>
            <Putout 2><Putout 2 '  Inequalities are cut:'<AddNewLines e.OldNegEqs>>
                <Putout 2 '  to'<AddNewLines e.CommonNeqs e.NegGenEqs>>
            <UnfoldMain t.Program
                <PrintIfTracing t.ProcessedAncNode>
                (<GenPath t.AncestorName>) t.Tree
            >;
        };
/* 10б. Узел обобщается --- обобщение в конфигурации предка (все прежние потомки конфигурации предка удаляются). */
    t.Program t.Node (e.Path t.Last) t.Tree
    , <GetNodeStatus t.Node> : (Generalized t.AncestorName (UpperGeneralization With ((Generic e.NewEquations)(Negative e.Negs)))(e.GenFullConf)(e.GenStack)(e.Assignments)(e.Children))
    , t.AncestorName : (e.AncestorList)
    , <FindNode (<GenPath t.AncestorName>) t.Tree> : t.AncestorNode0
    , <FindGenerEqs 
        (<GetParList ()e.GenFullConf>)
        (e.Assignments)
        <GetNodeNewEqs t.AncestorNode0><GetNodeGenericEqs t.AncestorNode0>
    > : e.GenerEqs
    , <FindGenerNegative 
        (<GetParList ()e.GenFullConf>)
        (e.Assignments)
        <GetNodeNegEqs t.AncestorNode0>
    > : e.GenerNegative
    , <GetNegativeRestrictionsFromProgramRules t.Program e.GenFullConf> : e.RulesNegative
    , <NullifyNodeEqs t.AncestorNode0> : t.AncN1
    , <PutNodeLets t.AncN1 (Let e.Assignments In (e.GenFullConf))> : t.AncN2
    , <DeleteNodeActiveData t.AncN2> : t.AncN3
    , <PutNodeStatus t.AncN3 Driven> : t.AncN4
    , <GenerateNewNode (e.AncestorList 0)> : t.NewNode0
    , <PutNodeStatus t.NewNode0 Undriven> : t.NewNode1
    , <PutNodeStack t.NewNode1 e.GenStack> : t.NewNode2
    , <PutNodeConfig t.NewNode2 e.GenFullConf> : t.NewNode3
    , <PutNodeNegEqs 
        <PutNodeNewEqsToOld 
            <PutNodeNewEqs t.NewNode3 e.NewEquations e.GenerEqs>
        > 
        <NegativeCleaning e.Negs e.RulesNegative e.GenerNegative>
    > : t.ProcessedNewNode
    , <PutNodeChildren t.AncN4 t.ProcessedNewNode e.Children> : t.ProcessedAncNode
        =	
        <UnfoldMain t.Program
            <PrintIfTracing t.ProcessedAncNode>
            (<GenPath t.AncestorName>) t.Tree
        >;
/* 11. Если узел не прогнан, запускаем прогонку. */
/* На самом нижнем уровне самая левая переменная - вызов: производим прогонку для этого вызова. */
    t.Program t.Node (e.Path) t.Tree
    , <GetNodeStatus t.Node> : Ready
    , <GetNodeStack t.Node> : e.Stack
    , <GetNodeName t.Node> : t.Name
    , <GetStackTop e.Stack> : (call t.fdata (args (arg e.Arg)))
    , t.fdata : (t.fname t.timestamp)
    , <PutNodeStatus t.Node ReadyForGenCheck> : t.Node1
    , <YieldDriving 
        <FindFunctionDef t.Program (call t.fdata (args (arg e.Arg)))> 
        t.fdata 
        (e.Arg) 
        t.Name 
        t.Node
    > : e.NewChildren (e.RuleSet) t.NewStatus
    , <PutNodeStatus 
        <RenameStackTop 
            <PutNodeChildren 
                t.Node1 
                e.NewChildren
            > 
            t.fname (e.RuleSet)
        > 
        t.NewStatus
    > : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            <PrintIfTracing t.ProcessedNode>
            (e.Path) t.Tree
        >;

/* 12. вычисления в узле завершены - вставляем данный узел в дерево с пометкой Finished. */
    t.Program t.Node (e.Path) t.Tree
    , <PutNodeStatus t.Node Finished> : t.ProcessedNode
        = <UnfoldMain 
            t.Program 
            t.ProcessedNode
            (e.Path) 
            <PrintIfTracing <InsertNode t.ProcessedNode(e.Path)t.Tree>>
        >;
}

GetFunRecursionType {
    ((t.fname (e.RSet)) t.timestamp)(e.1 (t.fname (Recursion s.Flag) e.OtherDef) e.2) = s.Flag;
    (t.fname t.timestamp)(e.1 (t.fname (Recursion s.Flag) e.OtherDef) e.2) = s.Flag;    
}

MarkAllEqs {
    (s.Log) = /* EMPTY */;
    (s.Log) (AreEqual (s.Log2)e.EqData) e.Rest
        = (AreEqual (s.Log)e.EqData)<MarkAllEqs (s.Log)e.Rest>;
}

/*
    Поиск определения функции, которую планируется выполнить.
   ([Program])[FunctionName] => ([e.FirstPattern])([e.FirstRightHandSide])((([Pattern])[RightHandSide])^*)
*/
FindFunctionDef {
    (e.ProgramBefore (t.fname e.Features (Sents e.Defs)) e.ProgramAfter) (call ((t.fname (e.RSet)) t.timestamp) e.Args)
        = <ExtractRuleSubset t.fname(e.Defs)>;
    (e.ProgramBefore (t.fname e.Features (Sents e.Defs)) e.ProgramAfter) (call (t.fname t.timestamp) e.Args)
        = <ExtractRuleSubset t.fname(e.Defs)>;
}

GetNegativeRestrictionsFromProgramRules {
    t.Program e.Config
    , <GetConfigCallsWithGaps e.Config> : e.Calls
    , <GetFailedClashes t.Program e.Calls> : e.NegativeData
         = <Putout 2 'Getting negative conditions from rules set:'>
         <Putout 2 <AddNewLines e.Calls>>
         <Putout 2 'produce conditions:'>
         <Putout 2 <AddNewLines e.NegativeData>>
            e.NegativeData;
}

GetFailedClashes {
    t.Program (s.FunName (s.Number e.FailedRules)(e.Arg)) e.Calls
    , <FindFunctionDef t.Program (call (s.FunName 0)(args (arg )))> : (s.PatternType)(e.LHS)(e.RHS)(e.Defs)
    , <FilterLHS (s.Number e.FailedRules)(1)(((s.PatternType)(e.LHS)e.RHS)e.Defs)> : e.LHSSet
    , <GetNegativeConditions (e.Arg)e.LHSSet> : e.NegativeConditions
        = <NormalizeInequalityBlock ( )e.NegativeConditions><GetFailedClashes t.Program e.Calls>;
    t.Program /* EMPTY */ = /* EMPTY */;
}

FilterLHS {
    (e.Sequence)(s.Current)(((s.PatternType)(e.LHS)e.RHS)e.Other)
    , e.Sequence
    : {
        e.Before s.Current e.Rest
            = ((s.PatternType)e.LHS)<FilterLHS (e.Rest)(<Add s.Current 1>)(e.Other)>;
        e.NotContainingCurrent
            = <FilterLHS (e.Sequence)(<Add s.Current 1>)(e.Other)>;
        };
    (e.Sequence)(s.Current)(/* EMPTY */) = /* EMPTY */;
}

GetNegativeConditions {
    (e.Expr)((s.Pattern)e.LHS)e.Other
        = (OR (s.Pattern)((e.Expr) to (e.LHS))) <GetNegativeConditions (e.Expr)e.Other>;
    (e.Expr) /* EMPTY */ = /* EMPTY */;
}

GetConfigCallsWithGaps {
    e.1 ('*'e.2)e.3 = <GetConfigCallsWithGaps e.1 e.2 e.3>;
    e.1 (call t.funname (args (arg e.Arg))) e.2
    , t.funname : ((s.InitName t.Rules) t.TimeStamp)
    , <SetMinus <GenNaturalSeq t.Rules> t.Rules>
    : {
        (t.SomeRuleNumber e.Other)
            = (s.InitName (t.SomeRuleNumber e.Other) (e.Arg)) <GetConfigCallsWithGaps e.Arg e.2>;
        (/* EMPTY */)
            = <GetConfigCallsWithGaps e.Arg e.2>;
    };
    e.Z = /* EMPTY */;
}

GenNaturalSeq {
    (e.Z s.Last)
        = <GenNaturalSeq Started (1)(s.Last)>;
    Started (e.Z s.Last)(s.Last) = (e.Z s.Last);
    Started (e.Z s.NotLast)(s.Last)
        = <GenNaturalSeq Started (e.Z s.NotLast <Add s.NotLast 1>)(s.Last)>;
}

ExtractRuleSubset {
    s.funname (((s.PatternType)(e.LHS)e.RHS)e.Defs) = (s.PatternType)(e.LHS)(e.RHS)(e.Defs);
    (s.funname (e.Numbers))(e.Defs)
    , <ExtractRuleSubset Started (1)(e.Numbers)e.Defs> : ((s.PatternType)(e.LHS)e.RHS)e.OtherDefs
        = (s.PatternType)(e.LHS)(e.RHS)(e.OtherDefs);
    Started (s.Num)(s.Num e.Other)(e.Rule)e.RestRules 
        = (e.Rule)<ExtractRuleSubset Started (<Add s.Num 1>)(e.Other)e.RestRules>;
    Started (s.Num)(s.OtherNum e.Other)(e.Rule)e.RestRules 
        = <ExtractRuleSubset Started (<Add s.Num 1>)(s.OtherNum e.Other)e.RestRules>;
    Started (s.Num)()e.RestRules = ;
}

/*
    Запуск процесса прогонки.
   ([Pattern])([RightHandSide])([FunctionDefinition]^*) [FunctionName] 
   ([FunctionArgument]) 
   [NodeName] ((e.Restrictions)(e.LetExpressions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) =>
   [Tree]^+ (набор вершин - дочек [NodeName])
*/
YieldDriving {
    (e.LHS)((Restart))(e.RestDefs) t.fname (e.Config) t.NodeName ((e.Restrictions)(e.ConfigEquations)(e.FullConfig)(e.Stack)) 
        = <PushNodesScreening 
            <GenerateNextLevel 
                (1)(/* EMPTY */)(Unmod) t.NodeName (0) 
                ((e.Restrictions)(e.ConfigEquations)()(e.FullConfig)(e.Stack))
                (t.fname (Try e.Config)(SubsTo (Restart))(e.RestDefs))
                <PostProcessPRTC (/* EMPTY */)(/* EMPTY */)
                    <Drive ( )
                        <ClashLeft 0
                            <SaveDriveMarker 'dwevale_ind'> 
                            <SaveDriveMarker 'dwevalt_ind'>
                            <SaveDriveMarker 'dwevals_ind'>
                            <Putout 1 'New Clash: No ' <FreshIndex 'prtc_ind'>>
                            <Put 1
                                ((e.ConfigEquations (Desired))()()(((e.Config) to (e.LHS))(Delayed ))('T'))
                            >
                            <Putout 1>
                    >>
                >
            >
        >;
    (s.PatternType)(e.LHS)(e.RHS)(e.RestDefs) t.fname (e.Config) t.NodeName t.WholeNode
    , <Br 'PatternType='s.PatternType> : e.Z
    , <GetNodeEqs <PutNodeNewEqsToOld t.WholeNode>> : e.ConfigEquations
    , <ReplacePRTCAllEqs <GenerateFreshPRTC (e.LHS)(e.Config)> e.ConfigEquations> : t.PRTC
        = <PushNodesScreening
            <GenerateNextLevel 
                (1)(/* EMPTY */)(Unmod)t.NodeName (0) 
                t.WholeNode
                (t.fname (Try e.Config)(SubsTo e.RHS)(e.RestDefs))
                <PostProcessPRTC (/* EMPTY */)(/* EMPTY */)
                    <RenewIndices 'vare_ind'>
                    <RenewIndices 'vars_ind'>
                    <RenewIndices 'vart_ind'>
                    <Drive s.PatternType ()
                        <ClashLeft s.PatternType 0
                            <SaveDriveMarker 'dpare_ind'> 
                            <SaveDriveMarker 'dpart_ind'>
                            <SaveDriveMarker 'dpars_ind'>
                            <Putout 1 'New Clash: No '<FreshIndex 'prtc_ind'>>
                            <Putout 1 <FormatPRTCToPrint t.PRTC>>
                            t.PRTC
                            <Putout 1>
                        >
                    >
                >
                ReadyForGenCheck
            >
        >;
}

PushNodesScreening {
    e.Children (e.Rules) t.Status
    , <GetReadyNodes e.Children> :
        {t.Ch1 t.Ch2 e.ChOther
            = <AnalyzePushNodes (t.Ch1 t.Ch2 e.ChOther) e.Children> (e.Rules) t.Status;
        e.Z /* Количество push-потомков после прогонки меньше 2. */
            = e.Children (e.Rules) t.Status;
        };
}

GetReadyNodes {
    t.Node e.Other
    , <GetNodeStatus t.Node> : 
        {Ready
            = t.Node <GetReadyNodes e.Other>;
        e.Z
            = <GetReadyNodes e.Other>;
        };
    /* EMPTY */ = /* EMPTY */;
}

AnalyzePushNodes {
    (t.Node) e.Children = e.Children;
    (t.Node e.Other) e.Children
    , <GetNodeRestrictions t.Node> : e.Restrs
    , <CheckNarrowingsScreening (e.Restrs)(e.Other)> :
        { t.OtherNode
        , e.Children : e.Ch1 t.Node e.Ch2
            =  <AnalyzePushNodes (e.Other) e.Ch1 e.Ch2>;
        /* EMPTY */
            = <AnalyzePushNodes (e.Other) e.Children>;
        };
}

EquivalentEqSet {
    (e.1)e.1 = 'T';
    (e.1 t.1 e.2) e.3 t.1 e.4 = <EquivalentEqSet (e.1 e.2) e.3 e.4>;
    (e.1 (AreEqual t.Log1 t.LHS t.RHS) e.2) e.3 (AreEqual t.Log2 t.RHS t.LHS) e.4 
        = <EquivalentEqSet (e.1 e.2) e.3 e.4>;
    e.Other = 'F';
}

EquivalentNEqSet {
    ( )e.1 = 'T';
    (e.1 t.1 e.2) e.3 t.1 e.4 = <EquivalentNEqSet (e.1 e.2) e.3 e.4>;
    e.Other = 'F';
}

FindEqsIntersection {
    (e.OldEqs)(e.SubbedEqs)e.NewEqs
        = <FindEqsIntersection Started (<Zip (e.OldEqs)(e.SubbedEqs)>)e.NewEqs>;
    Started ((t.0 t.1) e.1) e.20 t.1 e.21 = t.0 <FindEqsIntersection Started (e.1)e.20 t.1 e.21>;
    Started ((t.0 t.1) e.1) e.2
    , <IfEqIsImplied t.1(e.2)> :
        {'F'
            = <FindEqsIntersection Started (e.1)e.2>;
        'T'
            = t.0 <FindEqsIntersection Started (e.1)e.2>;
        };
    Started (/* EMPTY */) e.2 = /* EMPTY */;
}

$ENTRY Zip {
    (t.1 e.1)(t.2 e.2) = (t.1 t.2)<Zip (e.1)(e.2)>;
    ()() = ;
}

GetOldVariant {
    t.0 t.1 = t.0;
    t.0 = ;
}

/*
    Выбор дочернего узла с незавершенной разверткой.
   Выбираем из списка дочерних вершин данной вершины те, которые имеют статус Driven, Undriven или Ready.
   Если таких вершин нет, вставляем данную вершину в дерево с пометкой Finished.
   Формат функции:
   [ParentNode]([ChildNode]^*)[path][tree]=>[Node][path][tree]
*/
ChooseSuccessorNode {
/* 1. У данной вершины нет дочерних вершин, в которых не доделана развертка -> вершина помечается как Finished */
    t.Node (/* EMPTY */)(e.Path)(e.Tree)
    , <PutNodeStatus t.Node Finished> : t.Node1
    , <PutNodeChildren t.Node1> : t.Node2
    , <PutNodeLets t.Node2 (Subtree <FreshIndex 'Subtree'>)> : t.Node3
    , <DeleteNodeActiveData t.Node3> : t.ProcessedNode 
        = <Collapse <Br 'Subtree'<Symb <CurrentIndex 'Subtree'>>'='t.Node1>>
            t.ProcessedNode(e.Path)<InsertNode t.ProcessedNode(e.Path)(e.Tree)>;
/* 2. Очередной дочерний узел имеет статус завершенного (или зацикленного). Рассматриваем другие. */
    t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree)
    , <CheckAlter <GetNodeStatus t.ChildNode> EITHER Finished (Looped)> : True
        = <ChooseSuccessorNode t.Node (e.OtherChildren)(e.Path)(e.Tree)>;
/* 3. Нашелся искомый дочерний узел - возвращаем его и путь до него. */
    t.Node (t.ChildNode e.OtherChildren)(e.Path)(e.Tree)
    , <GetNodeName t.ChildNode> : t.ChildName
        = t.ChildNode <ProlongPath (e.Path) t.ChildName>(e.Tree);
}

CheckAlter {
    (t.x e.x) EITHER e.1 (t.x) e.2 = True;
    t.x EITHER e.1 t.x e.2 = True;
    t.x EITHER e.1 = False;
}

IsRoot {
    t.Node
    , <GetNodeName t.Node> : (t.Single)
        = True;
    t.Node = False;
}


/*
    Выбор ближайшего соседа со статусом незавершенной прогонки (если такой сосед есть)
   Формат функции
   (Node e.Node)(e.Path)(e.Tree)=>[nodeData][path][tree]
*/
ChooseUndrivenNode {
/* 1. Нашлась вершина, на которой не запускалась прогонка и проверка на повторность состояния - возвращаем ее. */
    t.Node t.Path t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Undriven Ready> : True 
        = t.Node t.Path t.Tree;
/* 2. Алгоритм дошёл до корня дерева и пометил его как Finished. Возвращаем корень. */
    t.Node t.Path t.Tree
    , <IsRoot t.Node> : True
    , <GetNodeStatus t.Node> : Finished
        = t.Node t.Path t.Tree;
/* 3. Если вершина имеет статус Finished, и это не корень, продолжаем поиск от ее родителя. */
    t.Node t.Path t.Tree
    , <CheckAlter <GetNodeStatus t.Node> EITHER Finished (Looped)> : True
    , <ShortenPath t.Path> : t.NewPath
        = <ChooseUndrivenNode <FindNode t.NewPath t.Tree>t.NewPath t.Tree>;
/*
   4. Если вершина имеет статус Driven, выбираем ее дочку со статусом Driven, Undriven или Ready и продолжаем поиск от нее
   если же таких дочек нет, то эта вершина получает статус Finished. 
*/
    t.Node t.Path t.Tree
    , <GetNodeStatus t.Node> : Driven
    , <GetNodeChildren t.Node> : e.Children
        = <ChooseUndrivenNode <ChooseSuccessorNode t.Node (e.Children)t.Path t.Tree>>;
}

/*
    Известно имя вершины-предка и путь от корня до ее потомка. Построить путь до вершины предка.
   ([path])t.NodeName => ([path])
*/
FindAncestorPath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore);
}

FindNodePath {
    (e.PathBefore t.NodeName e.PathAfter)t.NodeName = (e.PathBefore t.NodeName);
}

ProlongPath {
    (e.PathBefore) t.NodeName = (e.PathBefore t.NodeName);
}

ShortenPath {
    (e.PathBefore t.NodeName) = (e.PathBefore);
}

/* Для выхода по невозможному отождествлению. */
Recogn_Impossible {
    aaa = ;
}

/* Для трассировщика. */
AAA {
    e.1 = e.1;
}

/* Для трассировщика. */
PrintIfTracing {
*   e.1 = e.1;
    e.1 = e.1 <Putout 1 <FormatTreeToPrint e.1>>;
}
CutLetData {
    /* EMPTY */ = /* EMPTY */;
    (t.NodeName t.Assignment) e.Rest 
        = t.Assignment <CutLetData e.Rest>;
}

FindGenerNegative {
    (e.Parameters)((t.NodeNum (assign t.newpar((par e.oldpar))))e.OtherAssignments) e.Neg
        = <FindGenerNegative (e.Parameters)(e.OtherAssignments)
            <SubstituteInNegative ((assign (par e.oldpar)(t.newpar)))e.Neg>>;
    (e.Parameters)((t.NodeNum (assign e.OtherExpr))e.OtherAssignments) e.Equations
        = <FindGenerNegative (e.Parameters)(e.OtherAssignments)e.Equations>;
    (e.Parameters)()(OR (s.Log)e.Clashes)e.OtherOR
    , <CheckParSet(e.Parameters)(e.Clashes)> : 
        {'T'
            = (OR (s.Log)e.Clashes)<FindGenerNegative (e.Parameters)()e.OtherOR>;
        'F'
            = <FindGenerNegative (e.Parameters)()e.OtherOR>;
        };
    (e.Parameters)() = ;
}

FindGenerEqs {
    (e.Parameters)((t.NodeNum (assign t.newpar((par e.oldpar))))e.OtherAssignments) e.Equations
        = <FindGenerEqs (e.Parameters)(e.OtherAssignments) <Substitute ((assign (par e.oldpar)(t.newpar)))e.Equations>>;
    (e.Parameters)((t.NodeNum (assign e.OtherExpr))e.OtherAssignments) e.Equations
        = <FindGenerEqs (e.Parameters)(e.OtherAssignments)e.Equations>;
    (e.Parameters)()(AreEqual (s.Log)(e.LHS)(e.RHS))e.OtherEqs
    , <CheckParSet(e.Parameters) e.LHS e.RHS>: 
        {'T'
            = (AreEqual ('F')(e.LHS)(e.RHS))<FindGenerEqs (e.Parameters)()e.OtherEqs>;
        'F'
            = <FindGenerEqs (e.Parameters)(/* EMPTY */)e.OtherEqs>;
        };
    (e.Parameters)(/* EMPTY */) = /* EMPTY */;
}

CheckParSet {
    (e.Parameters) = 'T';
    (e.Parameters) ('*' e.1) e.2 = <LogAnd <CheckParSet (e.Parameters)e.1><CheckParSet (e.Parameters)e.2>>;
    (e.Parameters) (call t.fname (args (arg e.1))) e.2 = <LogAnd <CheckParSet (e.Parameters)e.1><CheckParSet (e.Parameters)e.2>>;
    (e.Parameters) (par e.par) e.2
    , <InSet (par e.par)e.Parameters> :
        {'T'
            = <CheckParSet (e.Parameters)e.2>;
        'F' = 'F';
        };
    (e.Parameters) ((e.1) to (e.2)) e.Other = <CheckParSet (e.Parameters) e.1 e.Other>;    
    (e.Parameters) t.1 e.1 = <CheckParSet (e.Parameters)e.1>;
}

InSet {
    t.1 e.1 t.1 e.2 = 'T';
    t.1 e.Other = 'F';
}

FindNEqsIntersection {
    (e.1 t.1 e.2) e.11 t.1 e.12 = <FindNEqsIntersection (e.1 e.2) e.11 t.1 e.12>;
    (t.1 e.1) e.2 = <PreserveNeqIfImplied t.1 (e.2)><FindNEqsIntersection (e.1)e.2>;
    () e.2 = /* EMPTY */;
}

PreserveNeqIfImplied {
    (OR ('T')((e.RHS) to (e.LHS))) e.Neqs
    , <ProcessLinearInequality ((e.RHS) to (e.LHS))> : (OR t.SingleIneq)
        = <PreserveNeqIfImplied (OR ('T') t.SingleIneq)e.Neqs>;
    t.1 e.N1 t.1 e.N2 = t.1;
    e.Z = /* EMPTY */;
}

GetPreservedEqs {
    (e.OldEqs)(e.SubEqs)(e.NewEqs)
     = <FindEqsIntersection 
        (e.OldEqs)(e.SubEqs) e.NewEqs 
        >;
}