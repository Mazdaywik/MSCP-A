/*
   Модуль функций обобщения и вложения.
   
   Доступные из модуля функции:
   
   HomeomorphicEmb --- проверка двух выражений на наличие гомеоморфного вложения. Формат:
   ([ExprToBeEmbedded])[ExprToEmbed] => [Log]
   
   CheckNode4Equivalence - проверка на наличие узла, выражение в котором есть подстановка в данное. 
   Формат:
   (Expression)[Path][Tree] => Ready | (Looped [NodeName] (assign (par e.par)((par e.newpar)))^*)
   
   FoldStackIntoConf - извлечение выражения из стека. Формат:
   ((assign (var l t.varname)(e.Val))^+)^+ => [Expression]
   
   CheckNode4Generalization - проверка на вложение (и построение обобщения, если оно существует). Формат:
   [CurrentNodeName]([CurrentConfiguration])([CurrentStack])([Path])[Tree]
   =>
   Driven | (Generalized [CurrentNodeName] (Looped [AncestorNodeName]) ([Configuration])([Stack])
   (Children ([NodeName] Undriven (([Eqs])([Restrs])([Config])([Stack])))^*))
*/

/* из basics.ref */
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, FindTerm, RenewIndices, FreshIndex, CurrentIndex,MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* из basics.ref */
$EXTERN Substitute,FindNode,CompareCalls,ComplexCompareCalls, Collapse,AddTime, RandomNumber;
/* из drive.ref */
$EXTERN FormatStack;
/* из stack.ref */
$EXTERN YieldDecomposition;
/* из formats.ref */
$EXTERN IsFreeExpression;
/* из residual.ref */
$EXTERN ConvertPrefal;
/* из access_MSCP.ref */
$EXTERN GetNodeConfig, GetNodeStack, GetNodeLets, PutNodeConfig, PutNodeStack, 
        GenerateNewNode, PutNodeLets, PutNodeNewEqs, PutNodeNewEqsToOld;


/*
   $ENTRY Go {
     = <MGUAssoc ((par e <MyZero>))((assign (par e <MyZero>) (ToUnify ('ABC')('BBA'))))()>}; 
*/

     

/* Для трассировщика. */
A {e.1 = e.1;}

/*
    Проверка, повторяет ли конфигурация в узле конфигурацию какого-либо предка этого узла.
   Если повторяет, узел помечается как зацикленный.
   Не повторяет - как готовый к проверке на обобщение.
   Вход:
   (Expression)[Path][Tree]
   Выход:
   Ready | (Looped [NodeName] [Assignments]) 
*/

$ENTRY CheckNode4Equivalence {
/* 1. Проверили всех предков. */
        (e.Data)()t.Tree = Ready;
/* 2. Нашли эквивалентный по конфигурации узел предка. */
	(e.Data)(e.Path t.NodeName)t.Tree, 
            <IfEquivalentConf ()(e.Data)<GetFullConf <FindNode (e.Path t.NodeName) t.Tree>>>:(e.subs) 
                = <RandomizedSaveTest e.Data>(Looped t.NodeName e.subs);
/* 3. Очередной узел не является эквивалентным - проверяем следующего предка по пути к корню. */
        (e.Data)(e.Path t.NodeName)t.Tree = <CheckNode4Equivalence (e.Data)(e.Path)t.Tree>;
}

RandomizedSaveTest {
    e.Data,
        <RandomNumber 1 1000> : 
        { 3 =   <Putout 3 e.Data>;
        s.Other = ;
        };
}

/*
    Функция формата: Извлечение из узла конфигурации его терма. 
   Вход:
   (Node [NodeStatus] [NodeName] (([Restrictions])([Equations])([NegativeInfo])(Configuration)[Stack][Children]))
   Выход:
   (Configuration)
*/
GetFullConf {
/* 1. Извлекаем полную конфигурацию терма, если он не есть let-расщепление. */
    t.Node, <GetNodeLets t.Node> : (), <GetNodeConfig t.Node> : e.FullConf = (e.FullConf);
/* 2. Если узел содержит let-расщепление, его не проверяем. */
    t.Node = False;
}

/*
    Свертка стека в единое выражение.
   ((assign (var l t.varname)(e.Val))^+)^+ => [ExpressionWithCalls]
*/
$ENTRY FoldStackIntoConf {
/* 1. Выражение построено. */
    ((assign (var l e.varname) (e.Val))) = <DeleteObjectives e.Val>;
/* 2. Исчерпали переменные уровня -> переходим к следующему. */
    ()(e.NextLevel)e.UpperLevels
        = <FoldStackIntoConf (e.NextLevel)e.UpperLevels>;
/* 3. Подставляем значение стековой переменной вместо ее самой в верхний уровень. */
    ((assign (var l e.varname) (e.Val))e.ThisLevel)(e.NextLevel)e.UpperLevels    
        = <FoldStackIntoConf (e.ThisLevel)(<Substitute ((assign (var l e.varname) (e.Val)))e.NextLevel>)e.UpperLevels>;
}

/*
    Удаление объектных термов с внешнего уровня.
   [Expression] => {(call e.call)|(par e t.parname)}^*
*/
DeleteObjectives {
    e.Val = e.Val;
/*
    (call e.call)e.Val = (call e.call) <DeleteObjectives e.Val>;
    ('*'e.Val1)e.Val2 = <DeleteObjectives e.Val1><DeleteObjectives e.Val2>;
    s.1 e.Val = <DeleteObjectives e.Val>;
    (par e e.pardata) e.Val = (par e e.pardata) <DeleteObjectives e.Val>;
    (par e.pardata) e.Val = <DeleteObjectives e.Val>; 
*/

}

/*
    Проверка двух конфигураций на совпадение по модулю имен параметров.
   ([Substitutions])([Expression])([Expression]|False)=>([ParAssignment]^*)|False 
*/

IfEquivalentConf {
/* 1. Завершена успешно. Проверяем, есть ли разные подстановки в один и тот же параметр. */
    (e.subst)(e.1)(e.1) = <IfCorrectSubs e.subst>;
/*
   2. Параметры равных типов считаются эквивалентными. Это правило стоит выше правила 3 (о равных термах), 
   чтобы не терялась подстановка параметра в себя. 
*/

    (e.subst)((par s.type e.x)e.Conf1)((par s.type e.y)e.Conf2) 
            = <IfEquivalentConf 
                    (e.subst (assign (par s.type e.x)((par s.type e.y))))
                    (e.Conf1)(e.Conf2)
            >;
/* 3. Равные термы эквиваленты. */
    (e.subst)(t.1 e.Conf1)(t.1 e.Conf2)
            = <IfEquivalentConf (e.subst)(e.Conf1)(e.Conf2)>;
/*
   4. Сопоставление друг другу выражений со скобками успешно, если части выражений, отделенные скобками, эквивалентны.
   Через LogAnd --- поскольку нам важно, где именно стоят скобки.
   Т.е. ('A')'B' не эквивалентно ('AB'), из-за положения скобок. 
*/

    (e.subst)(('*' e.Conf11) e.Conf12)(('*' e.Conf21) e.Conf22),
    <IfEquivalentConf (e.subst)(e.Conf11)(e.Conf21)> : (e.newSubst) 
            = <IfEquivalentConf (e.newSubst)(e.Conf12)(e.Conf22)>;
/* 5. Эквивалентность вызовов = эквивалентность аргументов и совпадение имен функций. */
    (e.subst)((call t.fname1 (args (arg e.Conf1Arg))) e.Conf1)((call t.fname2 (args (arg e.Conf2Arg))) e.Conf2),
    <CompareCalls t.fname1 t.fname2> : 'T',
    <IfEquivalentConf (e.subst)(e.Conf1Arg)(e.Conf2Arg)> : (e.newSubst)
            = <IfEquivalentConf (e.newSubst)(e.Conf1)(e.Conf2)>;
/* 6. Иначе эквивалентности нет. */
    (e.subst)(e.1) e.2 = False;
}

/* Удаление повторных подстановок параметров и выход в противоречие, если в один и тот же подставляются различные. */
IfCorrectSubs {
	e.1 t.1 e.2 t.1 e.3 = <IfCorrectSubs e.1 t.1 e.2 e.3>;
	e.1 (assign t.data t.val) e.2 (assign t.data t.otherval) e.3 
            = False;
	e.Z = (e.Z);
}

/*---------------------------------------------------------------------------------
                                  ФУНКЦИИ ВЛОЖЕНИЯ
-----------------------------------------------------------------------------------*/

/*
    Вход: 
   [CurrentNodeName]([CurrentConfiguration])([CurrentStack])([Path])[Tree]
   Выход:
   Driven | (Generalized [CurrentNodeName] (Looped [AncestorNodeName]) ([Configuration])([Stack])
   (Children ([NodeName] Undriven (([Eqs])([Restrs])([Config])([Stack])))^*))
   Конфигурация, являющаяся MGU (обобщенная конфигурация), в список Children не входит.
*/
$ENTRY CheckNode4Generalization {
	t.SuccName s.Flag (e.FullConf)(e.Stack)(e.Path)t.Tree,
        s.Flag :
        {
        'T'
            = Driven;
        s.OtherFlag
            = <CheckNode4Generalization Started t.SuccName (e.FullConf)(e.Stack)(e.Path)t.Tree>;
        };
/* 1. Дошли до корня, и кандидатов на обобщение нет -> узел прогнан. */
	Started t.SuccName (e.FullConf)(e.Stack)()t.Tree = Driven;
/* 2. Проверяем наличие сходства с очередным узлом предка. Если оно есть, запускаем процесс обобщения. */
	Started t.SuccName (e.FullConf)(e.Stack)(e.Path t.NodeName)t.Tree,
            <Collapse <TimeElapsed 0>>
            <EmbeddingConfs 
                    <Putout 1 'Trying to embed: '>
                    (<GetFullConfPlusStack <FindNode (e.Path t.NodeName) t.Tree>>)
                    ((e.FullConf)(e.Stack))
            >
            <Collapse <AddTime ('emb_time') <TimeElapsed>>> : s.Depth 'T' 
                = <Putout 1 'Embedding is successful.'>
                    <YieldGeneralization (Depth s.Depth) t.SuccName t.NodeName
                        <GetFullConfPlusStack
                            <FindNode (e.Path t.NodeName) t.Tree>
                        >
                        <Collapse <TimeElapsed 0>>        
                        (e.FullConf)(e.Stack)
                    >
                    <AddTime ('mgu_time')<TimeElapsed>>;
/* 3. В противном случае осуществляем проверку на сходство очередной конфигурации предка. */
    	Started t.SuccName (e.FullConf)(e.Stack)(e.Path t.NodeName)t.Tree
                = <CheckNode4Generalization Started t.SuccName (e.FullConf)(e.Stack)(e.Path)t.Tree>;
}

/*
    Выделение из конфигурации узла стека и полного выражения.
   [Node] => ([Expression])([Stack])
*/
GetFullConfPlusStack {
        t.Node, <GetNodeConfig t.Node> : e.FullConf, 
        <GetNodeStack t.Node> : e.Stack
                = (e.FullConf)(e.Stack);
}

/*
    Функция-формат для запуска обобщения
   t.NameOfTheLowerNode t.NameOfTheUpperNode ([UpperConfigurationExpr])([LowerConfigurationExpr])
    =>
*/
YieldGeneralization {
/*
    (Depth s.1) t.SuccessorName t.UpperNodeName (e.UpperConf)(e.UpperStack)(e.LowerConf)(e.LowerStack) = 
                <AnalyzeMGUResults t.SuccessorName t.UpperNodeName (e.UpperConf) 
                    <MGUAssoc 
                            ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.UpperConf)(e.LowerConf))
                            ))
                    >
                >; 
*/

    (Depth s.Depth) t.SuccessorName t.UpperNodeName (e.UpperConf)(e.UpperStack)(e.LowerConf)(e.LowerStack),
        <IfEquivalentConf ()(e.UpperConf)(e.LowerConf)> : (e.Asgs)
            = <RandomizedSaveTest e.LowerConf><Putout 1 'Depth is 's.Depth>
            <AnalyzeMGUResults 
                t.SuccessorName t.UpperNodeName (e.UpperConf)(e.UpperConf)(<GenerateTrivialMGUs e.Asgs>)()
            >;
            
   (Depth s.Depth) t.SuccessorName t.UpperNodeName (e.UpperConf)(e.UpperStack)(e.LowerConf)(e.LowerStack) 
               = <RandomizedSaveTest e.LowerConf>               
                <AnalyzeMGUResults t.SuccessorName t.UpperNodeName (e.UpperConf) 
                    <Putout 1 'Depth is 's.Depth>
                    <MergeFreeParameters 
                        <FormatUnification (e.UpperConf)(e.LowerConf)>
                    >
                >;
}

/* (e.Pattern)(e.MGUs) => (e.Pattern)(e.MGUs) */
MergeFreeParameters {
/* e.1 = e.1; */
    (e.Pattern)(e.MGUs)
        = <SubstituteMergedPars (e.Pattern)(e.MGUs)()<SortFreeSeq (e.MGUs)<FindFreeSeq e.Pattern>>>;
}

/* e.ParameterizedExpression => ((par e t.name1)(par e t.name2))^* */
FindFreeSeq {
    e.1 (par e t.name1)(par e t.name2) e.2
        = ((par e t.name1)(par e t.name2)) 
        <FindFreeSeq e.1>
        <FindFreeSeq (par e t.name2) e.2>;
    e.1 (call t.fname (args (arg e.arg))) e.2 
        = <FindFreeSeq e.1><FindFreeSeq e.arg><FindFreeSeq e.2>;
    e.1 ('*' e.inbr) e.2
        = <FindFreeSeq e.inbr><FindFreeSeq e.2>;
    e.Z = ;
}

/*
    Дан список пар открытых параметров, стоящих рядом. Перевести их в формат, входной для SubstituteMergedPars.
   (e.MGUs) ((par e t.name1)(par e t.name2))^* => (ToMerge (par e t.name1)(par e t.name2))^* 
*/

SortFreeSeq {
    (e.MGUs) = ;
    (e.MGUs)e.1 t.1 e.2 t.1 e.3
        = <SortFreeSeq (e.MGUs) e.1 t.1 e.2 e.3>;
/*
    (e.MGUs)(t.par1 t.par2) e.triples,
    e.MGUs : e.1 (assign t.par1 e.data) e.2,
    e.MGUs : e.1 (assign t.par3 e.data) e.2 = <SortFreeSeq (e.MGUs) e.triples>;
    (e.MGUs)(t.par1 t.par2 t.par3) e.triples,
    e.MGUs : e.1 (assign t.par2 e.data) e.2 = <SortFreeSeq (e.MGUs) e.triples>; 
*/
    (e.MGUs)(t.par1 t.par2) e.pairs
        = (ToMerge t.par1 t.par2)<SortFreeSeq (e.MGUs) e.pairs>;
    (e.MGUs) t.triple e.triples
        = <SortFreeSeq (e.MGUs)e.triples>;
}

/*
    Удаление тех подстановок в обобщении, которые не встречаются в структуре.
   ([Expression])([Assignment]^*) => ([Expression])([Assignment]^*)
*/
DeleteNonInfMGUs {
    (e.Pattern)(e.1 (assign t.par e.data) e.2)
    , <IsInStructure t.par e.Pattern> : 'F'
        = <DeleteNonInfMGUs (e.Pattern)(e.1 e.2)>;
    e.Z = e.Z;
}

/*
    Дан список пар е-параметров, стоящих рядом и нуждающихся в слиянии (после обобщения).
   Построить это слияние.
   (e.Pattern)(e.MGUs)(e.Equations)(ToMerge (par e s.Name1)(par e s.Name2))^* => (e.Pattern)(e.MGUs)(e.Equations)
*/
SubstituteMergedPars {
    (e.Pattern)(e.MGUs)(e.Equations) = <DeleteNonInfMGUs (e.Pattern)(e.MGUs)>(e.Equations);
    (e.Pattern)(e.MGUs)(e.Equations)e.1 t.1 e.2 t.1 e.3 = <SubstituteMergedPars (e.Pattern)(e.MGUs)(e.Equations) e.1 t.1 e.2 e.3>;
    (e.Pattern)(e.MGUs)(e.Equations)(ToMerge t.par1 t.par2) e.ToMerge,
    <FindMGU t.par1 e.MGUs> : (assign t.par1 (e.Val11)(e.Val12)),
    <FindMGU t.par2 e.MGUs> : (assign t.par2 (e.Val21)(e.Val22)),
    <FreshIndex 'pare_ind'> : t.newind
        = <SubstituteMergedPars 
            (<SubstituteOnCond (t.par1)()((assign t.par1 ((par e t.newind)))(assign t.par2 ())) e.Pattern>)
            (e.MGUs (assign (par e t.newind) (e.Val11 e.Val21)(e.Val12 e.Val22)))
            (e.Equations (AreEqual ('F')((par e t.newind))(t.par1 t.par2)))            
            e.ToMerge
        >;
/*   (e.Pattern)(e.MGUs)(ToMerge (1) t.par1 t.par2) e.ToMerge,
    e.MGUs : e.1 (assign t.par2 (e.val1)(e.val2)) e.2
     = 
        <SubstituteMergedPars 
            (<SubstituteOnCond ()(t.par2)((assign t.par1 ())) e.Pattern>)
            (e.1 (assign t.par2 (t.par1 e.val1)(t.par1 e.val2)) e.2) 
            e.ToMerge
        >; 
*/
}

/*
    Подстановка при условии определенного соседства. Имеется пара подстановок и она подставляется в выражение,
   если и только если переменные в этом выражении, на которые есть подстановка, встречаются в нём рядом и в том же порядке.
*/
SubstituteOnCond {
    (e.Before)(e.After)(e.Subst) = ;
    (e.Before)(e.After)(e.Subst) ('*'e.1)e.2,
    <SubstituteOnCond (e.Before)(e.After)(e.Subst)e.1> : e.InBr
        = ('*'e.InBr)<SubstituteOnCond (e.Before)(e.After)(e.Subst)e.2>;
    (e.Before)(e.After)(e.Subst) (call t.fname (args (arg e.1)))e.2,
      <SubstituteOnCond (e.Before)(e.After)(e.Subst)e.1> : e.Arg
        = (call t.fname (args (arg e.Arg)))<SubstituteOnCond (e.Before)(e.After)(e.Subst)e.2>;
    (t.pred)(e.After)((assign t.pred (e.Val1)) (assign t.par (e.Val2))) t.pred t.par e.1
        = e.Val1 e.Val2 <SubstituteOnCond (t.pred)(e.After)((assign t.pred (e.Val1)) (assign t.par (e.Val2))) e.1>;
/*
    (e.Before)(t.post)((assign t.par (e.Val))) t.par t.post e.1 =
        e.Val t.post <SubstituteOnCond (e.Before)(t.post)((assign t.par (e.Val))) e.1>; 
*/
    (e.Before)(e.After)(e.Subst) t.1 e.1 =
        t.1 <SubstituteOnCond (e.Before)(e.After)(e.Subst) e.1>;
}

/*
    Замена стековой переменной свежим параметром.
   (s.Depth)(e.Stack)=>{(assign t.par (e.LowerExpr))|(NOTHING)}(e.OuterExpr)
   e.LowerExpr --- выражение, являющееся сверткой части стека, присвоенной параметру.
   e.OuterExpr --- свертка стека, лежащего ниже той части, которая была свернута в параметр. Теперь она содержит вхождение этого нового параметра.
*/
ReplaceStackLevelWithNewPar {
    (0)(((assign (var l t.name)(e.Val))e.LowerLevel))
    , <FreshIndex 'pare_ind'> : t.newparname 
        = (assign (par e t.newparname)(e.Val))((par e t.newparname));
    (0)(((assign (var l t.name)(e.Val))e.LowerLevel)e.OtherStack)
    , <FreshIndex 'pare_ind'> : t.newparname
        = 
        (assign (par e t.newparname)(e.Val))
        (<FoldStackIntoConf
            <Substitute ((assign (var l t.name)((par e t.newparname)))e.LowerLevel) e.OtherStack>>);
    (s.x)((e.LowerLevel)(e.UpperLevel)e.OtherStack) 
        = <ReplaceStackLevelWithNewPar (<Sub s.x 1>)((<Substitute (e.LowerLevel)e.UpperLevel>)e.OtherStack)>;
}

GenerateTrivialMGUs {
     = ;
    (assign t.par (e.Expr)) e.Rest = (assign t.par (t.par)(e.Expr)) <GenerateTrivialMGUs e.Rest>;
}

/* Функция, вызывающая функцию обобщения по результатам анализа и разбивки стека по отношению Турчина. */
FormatUnification {
/*
    (e.Asgs)(e.Top1)(e.UpperConf)(NOTHING)(e.LowerConf)
        = (e.UpperConf)(<GenerateTrivialMGUs e.Asgs>);   
*/
    
/*    (e.Bottom1)(e.UpperConf)(NOTHING)(e.LowerConf)
        = <MGUAssoc ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.UpperConf)(e.LowerConf))
                            ))()>;
    (NOTHING)(e.Bottom1)(assign t.parname2 t.STop2)(e.Bottom2) 
        = <MGUAssoc ((par e <FreshIndex 'pare_ind'>))
                            ((assign (par e <CurrentIndex 'pare_ind'>)
                                (ToUnify (e.Bottom1)(<Substitute ((assign t.parname2 t.STop2)) e.Bottom2>))
                            ))()>;
*/

    (e.Conf1)(e.Conf2)
    , <FreshIndex 'pare_ind'> : s.newpar
        =
        <MGUAssoc ((par e s.newpar))
                            ((assign (par e s.newpar)
                                (ToUnify (e.Conf1)(e.Conf2))
                            ))()>; 

/*
    (assign t.parname1 t.STop1)(e.Bottom1)(assign t.parname2 t.STop2)(e.Bottom2),
    <FreshIndex 'pare_ind'> : t.BottomPar,
    <MGUAssoc ((par e t.BottomPar))
    ((assign (par e t.BottomPar)
        (ToUnify (e.Bottom1)(e.Bottom2))))()
    > : (e.Pattern)(e.MGUs) 
        = (e.Pattern)(<SubstituteInMGUs ((assign t.parname1 t.STop1)(assign t.parname2 t.STop2))e.MGUs>);*/
}

SubstituteInMGUs {
    (e.Subst) = ;
    (e.Subst)(assign t.par (e.Val1)(e.Val2)) e.Rest
        = (assign t.par (<Substitute (e.Subst) e.Val1>)(<Substitute (e.Subst) e.Val2>))
            <SubstituteInMGUs (e.Subst)e.Rest>;
}

/*
    Смотрим результат построения обобщения: обобщение сверху или снизу?
   t.SuccessorName t.UpperNodeName (e.UpperConf)(e.Pattern)(e.MGUs) => 
   (Generalized t.GenNodeName (UpperGeneralization | Looped t.AncestorNodeName) ([Configuration])[Stack] (Children [Node]^*))
*/
AnalyzeMGUResults {
/* 0. Обобщение тривиально. */
    t.SuccessorName t.UpperNodeName (e.UpperConf)((par e t.name))(e.MGUs)(e.EquationsFromMerging) = Driven;

/* 1. Обобщение снизу. */
    t.SuccessorName t.UpperNodeName (e.UpperConf)(e.Pattern)(e.MGUs)(e.EquationsFromMerging),
        <IfEquivalentConf ()(e.UpperConf)(e.Pattern)> : (e.Subs),
        <SplitMGUs 1 e.MGUs> : e.Assignments,
	<DeleteTrivialSubs (e.Assignments)(e.Subs)e.Pattern> : (e.CheckedSubs) e.CheckedPattern 
            =
                    <Putout 2 'Generalized downwards: 't.SuccessorName' and 't.UpperNodeName' with upper config'>
                    <Putout 2 <ConvertPrefal e.UpperConf>>
                    <Putout 2>
                    <Putout 2 'Generalized Pattern: '>
                    <Putout 2 <ConvertPrefal e.CheckedPattern>>
                    <Putout 2 'Generalized MGUs: 'e.Assignments>
                    <Putout 2 'Generalized Equations: 'e.EquationsFromMerging>
                    <Putout 2>
                    <Putout 2 '*****************************************************************'>
                    <Putout 2>
                    (Generalized t.SuccessorName (<Put 2 Looped To t.UpperNodeName With e.CheckedSubs>) 
                    <ExtractStackAndConf e.CheckedPattern>
                    <GatherChildrenInfo  () () 
                        <GenerateChildrenOfGenNode (e.EquationsFromMerging)t.SuccessorName 1
                             e.Assignments
                        >
                    >
                    );
/* 2. Обобщение сверху. */
    t.SuccessorName t.UpperNodeName (e.UpperConf)(e.Pattern)(e.MGUs)(e.EquationsFromMerging),
        <SplitMGUs 0 e.MGUs> : e.Assignments,
	<DeleteTrivialSubs (e.Assignments)()e.Pattern> : (e.CheckedMGUs) e.CheckedPattern,
        <GenerateNewEquations e.MGUs> : e.NewEquations =
                    <Putout 2 'Generalized upwards: 't.SuccessorName' and 't.UpperNodeName' with upper config'>
                    <Putout 2 <ConvertPrefal e.UpperConf>>
                    <Putout 2>
                    <Putout 2 'Generalized Pattern: '>
                    <Putout 2 <ConvertPrefal e.CheckedPattern>>
                    <Putout 2 'Generalized MGUs: 'e.MGUs>
                    <Putout 2 'Generalized Equations: 'e.EquationsFromMerging e.NewEquations>
                    <Putout 2>
                    <Putout 2 '*****************************************************************'>
                    <Putout 2>
                    (Generalized t.UpperNodeName (UpperGeneralization With (e.EquationsFromMerging e.NewEquations)) <ExtractStackAndConf e.CheckedPattern>
                    <GatherChildrenInfo  () () 
                        <GenerateChildrenOfGenNode (e.EquationsFromMerging e.NewEquations) t.UpperNodeName 1
                             e.Assignments
                        >
                    >
                    );
}

/* (assign (e.pardata)(e.Val1)(e.Val2))^* => (AreEqual (('T') e.1)(('T') e.2)) */
GenerateNewEquations {
    e.MGUs1 (assign (par e t.name)()(s.Sym))e.MGUs2 
            =
            (AreEqual ('F')((par e t.name) s.Sym)(s.Sym(par e t.name))) 
            <GenerateNewEquations e.MGUs1 e.MGUs2>;
/* 16.12.16. Добавлено 2 правила. */ 
 e.MGUs1 (assign (par e t.name)()((par s t.name2)))e.MGUs2,
    <IsInStructure (par s t.name2) e.MGUs1 e.MGUs2> : 'T' 
            =
            (AreEqual ('F')((par e t.name) (par s t.name2))((par s t.name2)(par e t.name))) 
            <GenerateNewEquations e.MGUs1 e.MGUs2>;
    e.MGUs1 (assign (par e t.name)()((par t t.name2)))e.MGUs2,
    <IsInStructure (par t t.name2) e.MGUs1 e.MGUs2> : 'T'
            = 
            (AreEqual ('F')((par e t.name) (par t t.name2))((par t t.name2)(par e t.name))) 
            <GenerateNewEquations e.MGUs1 e.MGUs2>;
    e.MGUs1 (assign (par t t.name)(s.Sym1)(s.Sym2))e.MGUs2
            = 
            (AreEqual ('F')((weval e <FreshIndex 'wevale_ind'>)(par t t.name)(weval e <FreshIndex 'wevale_ind'>))(s.Sym1 s.Sym2)) 
            <GenerateNewEquations e.MGUs1 e.MGUs2>;
    e.MGU = ;
}

/*
    Проверка, входит ли параметр в выражение.
   (par e.pardata)[Expression] => s.Log 
*/

IsInStructure {
    t.par e.1 t.par e.2 = 'T';
    t.par e.1 (assign t.par1 (e.val1)) e.2 = <IsInStructure t.par e.1 t.par1 e.val1 e.2>;
    t.par e.1 (AreEqual ((s.Log)(e.MSet1)(e.Val1))((s.Log2)(e.MSet2)(e.Val2))) e.2 
        =  <IsInStructure t.par e.1 e.Val1 e.Val2 e.2>;
    t.par e.1 (AreEqual (s.Log)(e.Val1)(e.Val2)) e.2 = <IsInStructure t.par e.1 e.Val1 e.Val2 e.2>;
    t.par e.1 ('*' e.3) e.2 = <IsInStructure t.par e.1 e.3 e.2>;
    t.par e.1 (call t.fname (args (arg e.Arg))) e.2 = <IsInStructure t.par e.1 e.Arg e.2>;
    t.par e.Z = 'F';
}

/* Пока заглушка. */
DeleteTrivialSubs {
/*
    	(e.subs1 (assign (par t.type t.newname)((par t.type t.oldname))) e.subs2)(e.Asgnts) e.Pattern = 
		<DeleteTrivialSubs 
			(e.subs1 e.subs2)
			(<Substitute ((assign (par t.type t.newname)((par t.type t.oldname)))) e.Asgnts>)
			<Substitute ((assign (par t.type t.newname)((par t.type t.oldname)))) e.Pattern>
		>; 
*/

        (e.asgnts)()e.Pattern = (e.asgnts)e.Pattern;
	(e.asgnts) (e.subs)e.Pattern = (e.subs) e.Pattern;
}

/*
    Куски, обобщенные до е-выражений, выделяются в дочерние узлы (Форматирующая функция типа Zip).
   ([NewAssignment]^*)([Node]^*)([assignment][Node])^* =>([NewAssignment]^*)([Node]^*)
*/
GatherChildrenInfo {
    (e.assignments)(e.children) = (e.assignments)(e.children);
    (e.assignments)(e.children)((assign (par e.data)t.Val)(Node t.Status t.Name e.NodeData))e.others
     = <GatherChildrenInfo 
         (e.assignments (t.Name(assign (par e.data) t.Val)))
         (e.children (Node t.Status t.Name e.NodeData))
         e.others
        >;
}

/*
   */
GenerateChildrenOfGenNode {
/*1. Все дети по let порождены. */
	(e.NewEquations) t.UpperNodeName t.Counter =;
/* 2. Очередной дочерний узел порождается: в нем нет сужений, let-выражений, есть только стек и обшая конфигурация. */
/*
    	(e.NewEquations) (e.UpperNodeName) t.Counter (assign (par e.pardata)(e.Val))e.Others,
        <GenerateNewNode (e.UpperNodeName t.Counter)> : t.BlankNode,
        <PutNodeNewEqsToOld <PutNodeNewEqs <PutNodeLets t.BlankNode (par e.pardata)> e.NewEquations>> : t.NewChildNode,
        <ExtractStackAndConf e.Val> : (e.ChildConf)(e.ChildStack) =
            <CheckForCalls
                ((assign (par e.pardata) (e.Val))
                <PutNodeStack <PutNodeConfig t.NewChildNode e.ChildConf> e.ChildStack>)
            >
            <GenerateChildrenOfGenNode (e.NewEquations)(e.UpperNodeName) <MyInc t.Counter> e.Others>; 
*/

	(e.NewEquations) (e.UpperNodeName) t.Counter (assign (par e.pardata)(e.Val))e.Others,
        <GenerateNewNode (e.UpperNodeName t.Counter)> : t.BlankNode,
        <PutNodeNewEqsToOld <PutNodeNewEqs t.BlankNode e.NewEquations>> : t.NewChildNode,
        <ExtractStackAndConf e.Val> : (e.ChildConf)(e.ChildStack) =
            <CheckForCalls
                ((assign (par e.pardata) (e.Val))
                <PutNodeStack <PutNodeConfig t.NewChildNode e.ChildConf> e.ChildStack>)
            >
            <GenerateChildrenOfGenNode (e.NewEquations)(e.UpperNodeName) <MyInc t.Counter> e.Others>;
}

/* Проверка, не пуст ли стек у вновь порожденного узла. */
CheckForCalls {
/* 1. Стек пуст => неразложенная конфигурация является финальной конфигурацией. */
/*   ((assign e.assignment)(Node e.Node (e.Data()(e.Stack)))) = ((assign e.assignment)); */
/* 2. Стек непуст => оставляем все как есть. */
    e.Z = e.Z;
}

/*
    Дано выражение. Построить стек, соответствующий этому выражению, и это же выражение без внешних объектных термов.
   [Expression] => ([Expression])[Stack]
*/
ExtractStackAndConf {
    e.Value
    , <YieldDecomposition ((assign (var l (0))(e.Value)))> : e.Stack
        = (<FoldStackIntoConf e.Stack>)(e.Stack);
}

/*
    Расщепление подстановок в обобщении.
   s.Flag (assign t.Name ([FirstExpr])([SecondExpr]))^* => (assign t.Name ([Expr]))^*
   s.Flag=0 => выбираем первое значение в подстановке;
   s.Flag=1 => выбираем второе.
*/
SplitMGUs {
    s.Flag =;
    0 (assign (e.pardata)(e.Val1)(e.Val2)) e.MGUs = (assign (e.pardata)(e.Val1))<SplitMGUs 0 e.MGUs>;
    1 (assign (e.pardata)(e.Val1)(e.Val2)) e.MGUs = (assign (e.pardata)(e.Val2))<SplitMGUs 1 e.MGUs>;
}


/*
    Преобразование слоистого стека в список конечных списков имён функций.
   ((t.FunName^+)^*)((assign (var l t.id)(e.Val))^+)^* => (t.FunName^+)^* 
*/
StackForm4TurRel {
/* 1. Весь стек обработан, на верхнем уровне вызовов не было. */
    (e.NewForm)() = e.NewForm;
/* 2. Весь стек обработан, на верхнем уровне вызовы имелись. */
    (e.NewForm)(e.NewTerm) = e.NewForm;
/* 3. Текущий слой стека исчерпан без формирования нового терма -- списка вызовов функций (на слое были только объектные выражения). */
    (e.NewForm)()()e.OtherLevels = <StackForm4TurRel (e.NewForm ((Constant 0)))()e.OtherLevels>;
/* 4. Текущий слой стека исчерпан, сформирован список вызовов функций в нем. Помещаем этот список в плоскую форму и переходим к другому слою. */
    (e.NewForm)(e.NewTerm)()e.OtherLevels = <StackForm4TurRel (e.NewForm (e.NewTerm))()e.OtherLevels>;
/* 5. Вставляем имя функции в терм, перечисляющий все имена вызванных функций на слое. */
    (e.NewForm)(e.NewTerm)((assign (var l t.name)((call (t.fname t.timestamp) e.call)))e.ThisLevel)e.OtherLevels = 
        <StackForm4TurRel (e.NewForm)(<InsertNewFunName (t.fname t.timestamp) e.NewTerm>)(e.ThisLevel)e.OtherLevels>;
/* 6. Если очередная стековая переменная не есть вызов, игнорируем ее. */
    (e.NewForm)(e.NewTerm)((assign (var l t.name)(e.NotCall))e.ThisLevel)e.OtherLevels = 
        <StackForm4TurRel (e.NewForm)(e.NewTerm)(e.ThisLevel)e.OtherLevels>;
}

/*
    Вставка имени функции в список, если его там еще не было.
   t.NewName t.name^* => t.name^*
*/
InsertNewFunName {
	(t.fname t.timestamp1) e.Names1 (t.fname t.timestamp2) e.Names2 = e.Names1 (t.fname t.timestamp1) e.Names2;
	t.fname e.Names = e.Names t.fname;
}


/*
   Проверка, вкладывается ли информация узла в информацию о другом узле 
   по композиции отношений на стеках, уравнениях и термах. 
   ((e.Equations)(e.Config)(e.Stack))((e.Equations)(e.Config)(e.Stack)) => s.Log
*/
EmbeddingConfs {
/*
	((e.Equations)(e.Config)(e.Stack))((e.Equations2)(e.Config2)(e.Stack2)) =
		<LogAnd <SingleGapFHE (e.Stack)e.Stack2>
			<LogAnd 
				<HomeomorphicEmb (e.Config)e.Config2>
				<FHE4AllEqs 
					(<CurrentIndex 'EqGen_Complex'>)
					(e.Equations)(e.Equations2)
				>
			>
		>; 
*/
    ((e.Config)(e.Stack))((e.Config2)(e.Stack2))
    , <SingleGapFHE (<Put 1 <StackForm4TurRel ()()e.Stack>>)
        <Putout 1 ' and '>
        <Put 1 <StackForm4TurRel ()()e.Stack2>>> : 
        { 'F' = 'F';
            s.Depth
            , <HomeomorphicEmb (<Put 1 e.Config>)<Putout 1 ' and '><Put 1 e.Config2>> :
                {'F' = 'F';
                'T'
                , <ReplaceStackLevelWithNewPar (s.Depth)(e.Stack)> : (e.asg)(e.Bottom1)
                , <ReplaceStackLevelWithNewPar (s.Depth)(e.Stack2)> : (e.asg2)(e.Bottom2)
                    = s.Depth <HomeomorphicEmb (e.Bottom1)e.Bottom2>;
                };
        };
}

/*
    Проверка на одноразрывное отношение в строке.
   Начинаться обе строки должны с одного и того же терма.
   ([Term]^*)[Term]^* => s.Log 
*/

SingleGapFHE {
    (((t.1 t.TS1) e.1) e.11) ((t.1 t.TS2) e.21) e.22 = <TurRelat (0)(e.11) e.22>; 
	e.X = 'F';
}

TurRelat {
    (s.Depth)(e.1 t.1) e.2 t.1 = <TurRelat (s.Depth)(e.1) e.2>;
    (s.Depth)(e.1) e.2 = <TurRelatAux (s.Depth)(e.1) e.2>;
}

TurRelatAux {
    (s.Depth)() e.2 = s.Depth;
    (s.Depth)(((t.1 t.TS1) e.11) e.1)((t.1 t.TS2) e.12) e.2 = <TurRelatAux (<MyInc s.Depth>)(e.1)e.2>;
    (s.Depth)(e.1) e.2 = 'F';
}

/*
    Проверка, вкладывается ли выражение [Expr1] в выражение [Expr2] по Крускалу.
   Это гомеоморфное вложение примитивное --- оно не различает имена параметров.
   ([Expr1])[Expr2] => s.Log 
*/

$ENTRY HomeomorphicEmb {
    ()e.2 = 'T';
    (e.1) = 'F';
/* 0. Равное вкладывается в равное. */
    (t.1)t.1 = 'T';
/* 1. Два параметра одного типа всегда вкладываются друг в друга. */
    ((par s.type e.par1))(par s.type e.par2) = 'T';
/* 2. вызов f вкладывается в вызов f, если аргумент вкладывается в аргумент. */
    ((call t.fdata1 (args (arg e.call1))))(call t.fdata2 (args (arg e.call2)))
    , t.fdata1 : (t.fname t.TS1)
    , t.fdata2 : (t.fname t.TS2)
        = <HomeomorphicEmb (e.call1)e.call2>;
/* 4. выражение, не имеющее вызова f во внешней части, вкладывается в вызов f, если вкладывается в его аргумент. */
    (e.Expr1)(call t.fname2 (args (arg e.call2))) 
        = <HomeomorphicEmb (e.Expr1) e.call2>;
/* 5. выражения в скобках. */
    (('*' e.11))('*' e.21) = <HomeomorphicEmb (e.11)e.21>;

/*
   6. Все прочее - выражение в скобках
   вкладывается, если вкладывается либо в скобки, либо во внешнюю часть. 
*/

    (e.11)('*' e.21)
        = <HomeomorphicEmb (e.11)e.21>;
/*
   7. Неравное не вкладывается в неравное. 
   Здесь t.2 --- не вызов (см. пр-е 4), не скобочное выражение (см. пр-е 6). 
*/
    (t.1 e.1) t.2 = 'F';
/*
   8. терм + что-то ещё - терм+что-то ещё вкладываются либо последовательно;
   либо все вместе в терм, либо все вместе в что-то ещё. 
*/
    (t.1 e.otherConf1)t.2 e.otherConf2
        = <KruskalAux2 
            <HomeomorphicEmb (t.1 e.otherConf1) t.2>
            (t.1 e.otherConf1)t.2 e.otherConf2
        >;
} /* HomeomorphicEmb */


/* Вспомогательная функция HomeomorphicEmb, имитирующая ленивое исполнение функции LogOr. Предложение 9. */
KruskalAux2 {
    'T'e.1 = 'T';
    'F'(t.1 e.otherConf1)t.2 e.otherConf2
        = <HomeomorphicEmb
            <IfThenElse 
                <HomeomorphicEmb (t.1)t.2>
                ((e.otherConf1)e.otherConf2) 
                (t.1 e.otherConf1) e.otherConf2
            >
        >;
}

/* s.Log (e.1)e.2 */
IfThenElse {
    'T'(e.1) e.2 = <AAA>e.1;
    'F'(e.1) e.2 = e.2;
}

/*
    Проверка вложения по уравнениям.
   [Equation] ::= (AreEqual (([MultiSet])([Expression]))(([MultiSet])([Expression]))) 
   ([Card])([Equation]^*)([Equation]^*) => s.Log
   [Card] --- натуральное число или Inf.
*/
FHE4AllEqs {
/* 1. Все уравнения исчерпаны. */
	(t.EqGenComplexity)()(e.Eqs2) = 'T';
/*
   2. Если уравнение в первом аргументе имеет сложность меньше или равную ограничивающей, 
   оно должно вкладываться в какое-нибудь уравнение во втором аргументе. 
*/

	(t.EqGenComplexity)((e.Equation1)e.OtherEqs1)(e.Eqs2), <MyIfNotLess t.EqGenComplexity <EqGenComplexity e.Equation1>>:'T' =
		<LogAnd
			<HomeomorphicEmb4Equations ((e.Equation1))e.Eqs2>
			<FHE4AllEqs (t.EqGenComplexity)(e.OtherEqs1)(e.Eqs2)>
		>;
/* 3. Если уравнение в первом аргументе имеет более высокую сложность, его игнорируем. */
	(t.EqGenComplexity)((e.Equation1)e.OtherEqs1)(e.Eqs2) =
			<FHE4AllEqs (t.EqGenComplexity)(e.OtherEqs1)(e.Eqs2)>;
}

/*
    Проверка вложимости уравнения в группу уравнений.
   Выполняется, если уравнение вкладывается в какое-либо уравнение из группы гомеоморфно,
   причём либо левая часть в правую и наоборот, либо левая в левую и правая в правую.
   [Equation] [Equation]^* => s.Log
*/
HomeomorphicEmb4Equations {
	t.Eq  = 'F';
	t.Eq1 t.Eq2 e.OtherEqs, 
	t.Eq1 : (AreEqual ((e.CompLHS1)(e.LHS1))((e.CompRHS1)(e.RHS1))), 
	t.Eq2 : (AreEqual ((e.CompLHS2)(e.LHS2))((e.CompRHS2)(e.RHS2))) =
		<LogOr
			<LogOr 
				<LogAnd
					<HomeomorphicEmb (e.LHS1)e.LHS2>
					<HomeomorphicEmb (e.RHS1)e.RHS2>
				>
				<LogAnd
					<HomeomorphicEmb (e.RHS1)e.LHS2>
					<HomeomorphicEmb (e.LHS1)e.RHS2>
				>
			>
			<HomeomorphicEmb4Equations t.Eq1 e.OtherEqs>
		>;
}

/*
    Функция вычисления сложности уравнения.
   Сложность уравнения --- это суммарное количество вхождений в него всех параметров.
   Здесь также считается, что если в уравнение входит строковая переменная (не параметр), оно имеет сложность Nat (Inf).
   Поэтому такие уравнения всегда игнорируются (упрощение!).
   [Equation] => [Card] 
*/


EqGenComplexity {
	(AreEqual (s.Log)(e.LHS)(e.RHS))
            = <MyAdd <SEGCompl e.LHS><SEGCompl e.RHS>>;
}

/*
    Функция вычисления сложности одной части уравнения.
   [MultiSet] => [Card]
*/
SEGCompl {
	 = <MyZero>;
	(weval e.Z) e.Other = Inf;
	(par e.Z) e.Rest = <MyAdd 1 <SEGCompl e.Rest>>;
        ('*'e.InBr) e.OutBr = <MyAdd <SEGCompl e.InBr><SEGCompl e.OutBr>>;
        t.Other e.Rest = <SEGCompl e.Rest>;
}

/*
    ([Pattern])((assign (e.Name) (ToUnify (e.1)(e.2)) => ([Pattern])((assign (e.Name) (ToUnify (e.1)(e.2))
   Самый первый вызов --- [Pattern] всегда e-параметр. 
*/

FindMaxContext {
/* 0. Обобщать больше нечего. Этой ситуации в программе быть не должно, выделена для теста! */
/*    (e.Pattern)((ToUnify ()())) = (e.Pattern)(); */

/* 1a. Полностью одинаковые термы слева образуют общий контекст. */
    (e.Pattern)((assign (e.Name)(ToUnify (t.1 e.1)(t.1 e.2)))) = 
        <FindMaxContext 
            (<Substitute ((assign (e.Name)(t.1 (e.Name)))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/* 1б. Полностью одинаковые термы справа образуют общий контекст. */
    (e.Pattern)((assign (e.Name)(ToUnify (e.1 t.1)(e.2 t.1)))) = 
        <FindMaxContext 
            (<Substitute ((assign (e.Name)((e.Name) t.1))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/* 2. Одинаковые вызовы функций, если кроме этих функций на данном уровне ничего нет, также образуют общий контекст. */
    (e.Pattern)((assign (e.Name)(ToUnify ((call t.fname (args (arg e.1))))((call t.fname (args (arg e.2))))))) = 
        <FindMaxContext 
            (<Substitute ((assign (e.Name)((call t.fname (args (arg (e.Name))))))) e.Pattern>)
            ((assign (e.Name)(ToUnify (e.1)(e.2))))
        >;
/* 3. Во всех остальных случаях общего контекста нет. */
    (e.Pattern)(e.ToUnify) = (e.Pattern)(e.ToUnify);
}

/*
----------------------------------------------------------------------------------------------------------------------------
   Most Generic Unification для ассоциативных данных.
   
   [MGUSub] ::= (assign (par s.type t.name)([Expr1])([Expr2]))
   [ToUnify] ::= (assign t.Name (ToUnify ([Expr])([Epr])))
   
   ([Expr])([ToUnify]^*)([MGUSub]^*)
   =>
   ([Expr])([MGUSub]^*)
   
   1ый аргумент --- текущий вариант Most Generic Unification (шаблон).
   2ой аргумент --- список кусков --- параметров из первого аргумента, которые ещё нужно обобщить.
   3ий аргумент --- текущий набор порожденных подстановок.
-------------------------------------------------------------------------------------------------------------------------------
*/

$ENTRY MGUAssoc {
/* 1. Обобщать больше нечего. */
    (e.Pattern)()(e.MGUs) = (e.Pattern)(e.MGUs); 
/* 2. Обобщаются равные выражения --- это выражение просто подставляется в шаблон вместо параметра. */
    (e.Pattern)(e.Other1 (assign (par e t.Name)(ToUnify t.val t.val))e.Other)(e.MGUs) =
        <MGUAssoc (<Substitute ((assign (par e t.Name)t.val)) e.Pattern>)(e.Other1 e.Other)(e.MGUs)>;
/* 3. Обобщаются термы, вызовы, параметры либо выражения в скобках --- передача управления MGUObject. */
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1)(t.Object2)))e.Other)(e.MGUs),
    <HomeomorphicEmb (t.Object1) t.Object2> : 'T' = 
            <MGUAssoc
                <MGUObject (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1)(t.Object2)))e.Other)
                    (e.MGUs)
                >
            >;
/* 4. Пустое выражение обобщается с непустым --- до e-выражения. */
    (e.Pattern)((assign (par e t.Name)(ToUnify ()(e.Object)))e.Other)
        (e.MGUs) = 
            <MGUAssoc <IntroduceEMGU (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)(assign (par e t.Name)()(e.Object))(e.Pattern)(e.Other)(e.MGUs)
            >>;
/* 5. Выражение и терм обобщаются успешно, только если выражение вкладывается в этот терм. В этом случае они обобщаются до e-переменной. */
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object)))e.Other)(e.MGUs),
	<HomeomorphicEmb (t.Object1 e.Expr1)t.Object> : 'T' = 
            <MGUAssoc <IntroduceEMGU (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)(assign (par e t.Name)(t.Object1 e.Expr1)(t.Object))(e.Pattern)(e.Other)(e.MGUs)
            >>;
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object)))e.Other)(e.MGUs),
	<HomeomorphicEmb (t.Object1 e.Expr1)t.Object> : 'F' = (False)(False); 
            
/* 4а. Пустое выражение обобщается с непустым --- до e-выражения. */
/*  (e.Pattern)((assign (par e t.Name)(ToUnify (e.Object)()))e.Other)
        (e.MGUs) = 
            <MGUAssoc <IntroduceEMGU (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)(assign (par e t.Name)(e.Object)())(e.Pattern)(e.Other)(e.MGUs)
            >>; 
*/

/* 6. Все остальные случаи: либо объекты обобщаются друг с другом, остальное друг с другом, либо объект + выражение со всем, другой объект - с пустым. */
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object2 e.Expr2)))e.Other)(e.MGUs),
    <HomeomorphicEmb (t.Object1)t.Object2> : 'T' = 
            <MinMGU
                    (<MGUAssoc <ProceedMGU 
                        (<FreshIndex 'pare_ind'>)(<FreshIndex 'pare_ind'>)
                        (par e t.Name)
                        ((t.Object1)(t.Object2))
                        ((e.Expr1)(e.Expr2))
                        (e.Pattern)
                        (e.Other)
                        (e.MGUs)
                >>)
                (<MinMGU    
                    (<MGUAssoc <ProceedMGU 
                        (<FreshIndex 'pare_ind'>)(<FreshIndex 'pare_ind'>)
                        (par e t.Name)
                        (()(t.Object2))
                        ((t.Object1 e.Expr1)(e.Expr2))
                        (e.Pattern)
                        (e.Other)
                        (e.MGUs)
                >>)
			(<MGUAssoc <ProceedMGU 
                        (<FreshIndex 'pare_ind'>)(<FreshIndex 'pare_ind'>)
                        (par e t.Name)
                        ((t.Object1 e.Expr1)(t.Object2))
                        (()(e.Expr2))
                        (e.Pattern)
                        (e.Other)
                        (e.MGUs)
                >>)
                >)
		>;
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Object1 e.Expr1)(t.Object2 e.Expr2)))e.Other)
        (e.MGUs) = 
                <MGUAssoc <ProceedMGU 
                        (<FreshIndex 'pare_ind'>)(<FreshIndex 'pare_ind'>)
                        (par e t.Name)
                        (()(t.Object2))
                        ((t.Object1 e.Expr1)(e.Expr2))
                        (e.Pattern)
                        (e.Other)
                        (e.MGUs)
                >>;
    (e.Pattern)(e.ToUnify)(e.MGUs) = (False)(False); 
}/* MGUAssoc */

/*
    Функция передачи построения обобщения другой функции.
   (t.ParName)(t.ParName)(par e t.Name)(([Expr1])([Expr2]))([Expr3])([Expr4])([ExprPattern])([ToUnify])([MGUSub]^*) =>
   ([Expr])([ToUnify]^*)([MGUSub]^*)
   Первые два имени --- два новых имени переменных, на которых разбивается третья.
*/
ProceedMGU {
/* 1. Передаем управление MGUObject. */
    (t.NewName1)(t.NewName2)(par e t.Name)((t.Expr11)(t.Expr12))((e.Expr21)(e.Expr22))(e.Pattern)(e.ToUnify)(e.MGUs) =
                    <MGUObject 
                        (<Substitute ((assign (par e t.Name)((par e t.NewName1)(par e t.NewName2))))e.Pattern>)
                        (
                            (assign (par e t.NewName1) (ToUnify (t.Expr11)(t.Expr12)))
                            (assign (par e t.NewName2) (ToUnify (e.Expr21)(e.Expr22))) 
                            e.ToUnify
                        )
                        (e.MGUs)
                    >;
/* 1. Передаем управление IntroduceEMGU. */
    (t.NewName1)(t.NewName2)(par e t.Name)((e.Expr11)(e.Expr12))((e.Expr21)(e.Expr22))(e.Pattern)(e.ToUnify)(e.MGUs) =
                    <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.NewName1)(e.Expr11)(e.Expr12))
                        (<Substitute ((assign (par e t.Name)((par e t.NewName1)(par e t.NewName2))))e.Pattern>)
                        ((assign (par e t.NewName2) (ToUnify (e.Expr21)(e.Expr22))) e.ToUnify)
                        (e.MGUs)
                    >;
/*   (t.NewName1)(t.NewName2)(par e t.Name)(e.E1)(e.E2)(e.Pattern)(e.ToUnify)(e.MGUs) = (False)()(False); */
}

/*
    Обобщение двух единичных термов.
   ([Expr])((assign (par e t.Name)([Term])([Term]))[ToUnify]^*)([MGUSub]^*) =>
   ([Expr])([ToUnify]^*)([MGUSub]^*)
*/
MGUObject {
/* 1. Обобщение двух равных термов --- просто подстановка терма вместо е-переменной. */
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Val)(t.Val)))e.Other)(e.MGUs) 
        =
        (<Substitute ((assign (par e t.Name)(t.Val)))e.Pattern>)
        (e.Other)
        (e.MGUs);

/* 2. Обобщение двух разных символов или s-параметров до s-параметра (4 случая). */
    (e.Pattern)((assign (par e t.Name)(ToUnify (s.Sym1)(s.Sym2)))e.Other)(e.MGUs) 
        =
        <ProceedNewObjectMGU 
            (par s <FreshIndex 'pars_ind'>)
            (e.Pattern)((assign (par e t.Name)(ToUnify (s.Sym1)(s.Sym2)))e.Other)(e.MGUs)
        >;
    (e.Pattern)((assign (par e t.Name)(ToUnify (s.Sym1)((par s t.sname))))e.Other)(e.MGUs)
        = 
        <ProceedNewObjectMGU 
            (par s <FreshIndex 'pars_ind'>)
            (e.Pattern)((assign (par e t.Name)(ToUnify (s.Sym1)((par s t.sname))))e.Other)(e.MGUs)
        >;
/*
    (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname))(s.Sym2)))e.Other)(e.MGUs) =
                    <ProceedNewObjectMGU 
                        (par s <FreshIndex 'pars_ind'>)
                        (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname))(s.Sym2)))e.Other)(e.MGUs)
                    >; 
*/

    (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname1))((par s t.sname2))))e.Other)(e.MGUs) 
        =
        <ProceedNewObjectMGU 
            (par s <FreshIndex 'pars_ind'>)
            (e.Pattern)((assign (par e t.Name)(ToUnify ((par s t.sname1))((par s t.sname2))))e.Other)(e.MGUs)
        >;
/* 3. Обобщение двух вызовов одинаковых функций до вызова функции. */
    (e.Pattern)((assign (par e t.Name)(ToUnify ((call (t.fname t.TS1) (args (arg e.Arg1))))((call (t.fname t.TS2) (args (arg e.Arg2))))))e.Other)(e.MGUs)
        =
        (<Substitute ((assign (par e t.Name)((call (t.fname <FreshIndex 'time_stamp'>) (args (arg (par e t.Name)))))))e.Pattern>)
        ((assign (par e t.Name)(ToUnify (e.Arg1)(e.Arg2)))e.Other)
        (e.MGUs);
/* 4. Обобщение двух выражений в скобках до выражения в скобках. */
    (e.Pattern)((assign (par e t.Name)(ToUnify (('*' e.Expr1))(('*' e.Expr2))))e.Other)(e.MGUs)
        =
        (<Substitute ((assign (par e t.Name)(('*' (par e t.Name)))))e.Pattern>)
        ((assign (par e t.Name)(ToUnify (e.Expr1)(e.Expr2)))e.Other)
        (e.MGUs);
/* 5. Вызов функции и что-то ещё обобщаются до e-параметра (2 случая). */
    (e.Pattern)((assign (par e t.Name)(ToUnify ((call e.call))(e.Expr2)))e.Other)(e.MGUs) 
        = <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.Name)((call e.call))(e.Expr2))(e.Pattern)
                        (e.Other)(e.MGUs)
        >;
    (e.Pattern)((assign (par e t.Name)(ToUnify (e.Expr1)((call e.call))))e.Other)(e.MGUs) 
        =
        <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.Name)(e.Expr1)((call e.call)))(e.Pattern)
                        (e.Other)(e.MGUs)
        >;
/* 6. е-параметр и что-то ещё обобщаются до e-параметра (2 случая). */
    (e.Pattern)((assign (par e t.Name)(ToUnify ((par e t.EName))(e.Expr2)))e.Other)(e.MGUs) 
        =
        <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.Name)((par e t.EName))(e.Expr2))(e.Pattern)
                        (e.Other)(e.MGUs)
        >;
    (e.Pattern)((assign (par e t.Name)(ToUnify (e.Expr1)((par e t.EName))))e.Other)(e.MGUs) 
        =
        <IntroduceEMGU 
                        (<FindAllPredInPattern ()()(par e t.Name)e.Pattern>)
                        (assign (par e t.Name)(e.Expr1)((par e t.EName)))(e.Pattern)
                        (e.Other)(e.MGUs)
        >;
/* 7. Во всех прочих случаях обобщаемся до t-параметра. */
    (e.Pattern)((assign (par e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)(e.MGUs) 
        =
        <ProceedNewObjectMGU 
            (par t <FreshIndex 'part_ind'>)
            (e.Pattern)
            ((assign (par e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)
            (e.MGUs)
        >;    
}/* MGUObject */

/*
    Обобщение до t- или s-параметра.
   (par t.type t.NewName)([Expr])([ToUnify2Objects][ToUnify]^*)([MGUSub]^*) => 
   ([Expr])([ToUnify]^*)([MGUSub]^*)
   
   t.type ::= t|s
*/
ProceedNewObjectMGU {
    (par t.type t.NewName)(e.Pattern)((assign (par e t.Name)(ToUnify (t.Obj1)(t.Obj2)))e.Other)(e.MGUs) 
        =
        <CheckRepeatedMGUs 
            ()(<Substitute ((assign (par e t.Name)((par t.type t.NewName))))e.Pattern>)
                (e.Other)
                (<DeleteMGU (par e t.Name)e.MGUs> (assign (par t.type t.NewName)(t.Obj1)(t.Obj2)))
        >;
}

AAA { = ;}

/*
    Введение обобщения до е-переменной.
   Если эта e-переменная следует в шаблоне после другой e-переменной, следует их слить.
   (t.ParName^*)[MGUSub]([Expr])([ToUnify]^*)([MGUSub]^*) => 
   ([Expr])([ToUnify]^*)([MGUSub]^*)
*/
IntroduceEMGU {
/* КОСТЫЛЬ! Если нашлась повторная подстановка, стираем возможность сливать переменную. */
    ((e.Arbitrary1)(e.Arbitrary2))(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs),
    e.MGUs : e.MGUs1 (assign (par e t.OtherName)(e.Expr1)(e.Expr2)) e.MGUs2
        = <IntroduceEMGU ()(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs)>;
    /* 1. У е-параметра, который обобщаем, в шаблоне ровно 1 предшественник --- тоже е-параметр.
   Сливаем эти параметры, после чего проверяем подстановку на повторность. 
*/

    (((par e t.Name2))(e.Post))(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs),
    <PatternParameter (par e t.Name2) e.Other> : 'F'
        = <CheckRepeatedMGUs ()<ConcatenateMGUs (1)
            <FindMGU (par e t.Name2) e.MGUs>
            (assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(<DeleteMGU (par e t.Name2) e.MGUs>)
        >>;
    ((e.Pred)((par e t.Name2)))(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs),
    <PatternParameter (par e t.Name2) e.Other> : 'F' 
        =
        <CheckRepeatedMGUs ()<ConcatenateMGUs (0)
            (assign (par e t.Name)(e.Expr1)(e.Expr2))<FindMGU (par e t.Name2) e.MGUs>(e.Pattern)(e.Other)
            (<DeleteMGU (par e t.Name2) e.MGUs>)
        >>;
/* 2. Во всех других случаях просто проверяем новую подстановку на повторность и записываем в список ([MGUSub]^*) (последний аргумент). */
    (e.Arbitrary)(assign (par e t.Name)(e.Expr1)(e.Expr2))(e.Pattern)(e.Other)(e.MGUs) 
        =
        <CheckRepeatedMGUs ()(e.Pattern)(e.Other)(<DeleteMGU (par e t.Name) e.MGUs> (assign (par e t.Name)(e.Expr1)(e.Expr2)))>;
}

PatternParameter {
    t.name e.ToUn1 (assign t.name e.Vals) e.ToUn2 = 'T';
    e.other = 'F';
}

/*
    Проверка, нет ли уже введенного параметра, обе подстановки в который совпадают с имеющимися в [CurrentNewMGUSub].
   ([MGUSub]^*)([Expr])([ToUnify]^*)[MGUSub]^* [CurrentNewMGUSub] => ([Expr])([ToUnify]^*)([MGUSub]^*) 
*/

CheckRepeatedMGUs {
/* 1. Все подстановки проверены. */
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata) t.Val1 t.Val2)) 
        = (e.Pattern)(e.ToUnify)(e.Checked (assign (e.pardata) t.Val1 t.Val2));
/* 2. Нашлась подстановка с такими же значениями --- значит, наша подстановка есть просто подстановка одного е-параметра. */
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata1) t.Val1 t.Val2) e.Other (assign (e.pardata) t.Val3 t.Val4)),
    <LogAnd <ComplexCompareCalls  t.Val1 t.Val3><ComplexCompareCalls  t.Val2 t.Val4>> : 'T'
        = (<Substitute ((assign (e.pardata)((e.pardata1))))e.Pattern>)
        (e.ToUnify)
        (e.Checked (assign (e.pardata1) t.Val1 t.Val2) e.Other);
/* 3. Пока не нашлась --- ищем дальше. */
    (e.Checked)(e.Pattern)(e.ToUnify)((assign (e.pardata1) t.Val11 t.Val22) e.Other (assign (e.pardata) t.Val1 t.Val2))
        = <CheckRepeatedMGUs (e.Checked (assign (e.pardata1) t.Val11 t.Val22))(e.Pattern)(e.ToUnify)(e.Other (assign (e.pardata) t.Val1 t.Val2))>;
}


/*
    Поиск подстановки данного параметра.
   (par e.pardata)[MGUSub]^* => [MGUSub] 
*/

FindMGU {
/* 1. Нашли --- возвращаем. */
    t.Parameter e.First (assign t.Parameter e.Data)e.Other = (assign t.Parameter e.Data);
/* 2. Не нашли --- возвращаем тривиальную подстановку. */
    t.Parameter e.Subs = (assign t.Parameter (t.Parameter)(t.Parameter));
}

/*
    Удаление подстановки параметра.
   (par e.pardata)[MGUSub]^* => [MGUSub]^*
*/
DeleteMGU {
    t.parameter e.First (assign t.parameter e.Data) e.Other = e.First e.Other;
    t.parameter e.Other = e.Other;
}

/*
    Слияние двух е-параметров в один.
   [MGUSub][MGUSub]([Expr])([ToUnify]^*)([MGUSub]^*) => ([Expr])([ToUnify]^*)([MGUSub]^*)
*/
ConcatenateMGUs {
    (0)(assign (par e t.Name1)(e.Expr11)(e.Expr12))(assign (par e t.Name2)(e.Expr21)(e.Expr22))(e.Pattern)(e.Other)(e.MGUs) =
        (<Substitute ((assign (par e t.Name2)())) e.Pattern>)(e.Other)
        (e.MGUs (assign (par e t.Name1)(e.Expr11 e.Expr21)(e.Expr12 e.Expr22)));
    (1)(assign (par e t.Name1)(e.Expr11)(e.Expr12))(assign (par e t.Name2)(e.Expr21)(e.Expr22))(e.Pattern)(e.Other)(e.MGUs) =
        (<Substitute ((assign (par e t.Name1)())) e.Pattern>)(e.Other)
        (e.MGUs (assign (par e t.Name2)(e.Expr11 e.Expr21)(e.Expr12 e.Expr22)));
}

FirstEVar {
    (par e e.par) e.other = (par e e.par);
    e.other = 'F';
}

/*
    Для данного е-параметра ищем предшествующие ему термы в выражении.
   Если они все --- один и тот же е-параметр, это отмечается в выходе.
   (par e t.Name)e.Expr => [(False)|(par e t.Name1)]^*
*/
FindAllPredInPattern {
/* 1. Всё смотрено. */
    (e.Pred)(e.Post)(par e t.Name) = (e.Pred)(e.Post); 
/*
   2. В образце хотя бы перед одним вхождением этой переменной стоит символ, выражение в скобках, параметр узкого типа или вызов -> 
   присоединять не к чему (5 случаев). 
*/
    (e.Pred)(e.Post)(par e t.Name)t.pred (par e t.Name) e.Expr,
    <FirstEVar t.pred> : 'F', <FirstEVar e.Expr> : 'F' = (False)(False); 
    (e.Pred)(e.Post)(par e t.Name)t.pred (par e t.Name) e.Expr,
    <FirstEVar t.pred> : 'F', <FirstEVar e.Expr> : (par e t.Name2) 
        = <FindAllPredInPattern (e.Pred)(e.Post (par e t.Name2))(par e t.Name) e.Expr>; 
/* 3. перед вхождением этого параметра стоит другой е-параметр --- возвращаем его и продолжаем искать дальше. */
    (e.Pred)(e.Post)(par e t.Name)(par e t.Name2) (par e t.Name) e.Expr,
    <FirstEVar e.Expr> : (par e t.Name3)  
        = <FindAllPredInPattern (e.Pred (par e t.Name2))(e.Post (par e t.Name3))(par e t.Name) e.Expr>;
/* 3. перед вхождением этого параметра стоит другой е-параметр --- возвращаем его и продолжаем искать дальше. */
    (e.Pred)(e.Post)(par e t.Name)(par e t.Name2) (par e t.Name) e.Expr 
        = <FindAllPredInPattern (e.Pred (par e t.Name2))(e.Post)(par e t.Name) e.Expr>;
/* 4. За ближайшим термом не стоит проверяемый параметр --- продолжаем поиск. */    
    (e.Pred)(e.Post)(par e t.Name)s.Sym e.Expr = <FindAllPredInPattern (e.Pred)(e.Post)(par e t.Name)e.Expr>; 
    (e.Pred)(e.Post)(par e t.Name)('*'e.Expr1) e.Expr,
    <FindAllPredInPattern ()()(par e t.Name)e.Expr1> : (e.Pred1)(e.Post1) 
        = 
        <FindAllPredInPattern (e.Pred e.Pred1)(e.Post e.Post1)(par e t.Name)e.Expr>; 
    (e.Pred)(e.Post)(par e t.Name)(call t.fname (args (arg e.Expr1))) e.Expr,
    <FindAllPredInPattern ()()(par e t.Name)e.Expr1> : (e.Pred1)(e.Post1) 
        = 
        <FindAllPredInPattern (e.Pred e.Pred1)(e.Post e.Post1)(par e t.Name)e.Expr>; 
    (e.Pred)(e.Post)(par e t.Name)(par e.pardata) e.Expr = <FindAllPredInPattern (e.Pred)(e.Post)(par e t.Name)e.Expr>; 
}

/*
    Выбор обобщения с наибольшим весом. Вес считается как вес (точность) подстановок минус вес (неточность) образца.
   (([Expr])([MGUSub]^*))(([Expr])([MGUSub]^*)) => (([Expr])([MGUSub]^*))
*/
MinMGU {
    e.MaybeMGU1 ((False)(False)) e.MaybeMGU2, e.MaybeMGU1 e.MaybeMGU2 : (e.CorrectMGU) = e.CorrectMGU;
        ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2)) = 
                    <ChooseLeastMGU 
                        ((e.Pattern1)(e.Assignments1))
                        ((e.Pattern2)(e.Assignments2))
                        <Compare 
                            <Sub <WeightMGU (0)e.Assignments1><WeightPattern (0)e.Pattern1>>
                            <Sub <WeightMGU (0)e.Assignments2><WeightPattern (0)e.Pattern2>>
                        >
                    >;

}

/*
    Функция назначения весов для полученного обобщения - в доработке!
   ([Number])[Expr] => [Number]
*/
WeightPattern {
/* 1. Все посчитано. */
    (s.Weight) = s.Weight;
/* 2. Символ в шаблоне. */
    (s.Weight)s.Sym e.Pattern = <WeightPattern (<Add s.Weight 200>) e.Pattern>;
/* 3. Символьный параметр в шаблоне. */
    (s.Weight)(par s e.par) e.Pattern = <WeightPattern (<Add s.Weight 120>) e.Pattern>;
/* 4. Скобки в шаблоне. */
    (s.Weight)e.Pt1 ('*' e.InBracks) e.Pattern = <WeightPattern (<Add s.Weight 80>) e.Pt1 e.InBracks e.Pattern>;
/* 5. Термовый параметр в шаблоне. */
    (s.Weight)(par t e.par) e.Pattern = <WeightPattern (<Add s.Weight 70>) e.Pattern>;
/* 6. Вызов функции в шаблоне. */
    (s.Weight)e.Pt1 (call t.fname (args (arg e.arg))) e.Pattern = <WeightPattern (<Add s.Weight 120>) e.Pt1 e.arg e.Pattern>;
/* 7. Худшее --- е-параметр в шаблоне. */
/*  (s.Weight)e.Pt1 (par e e.par) e.Pt2 (par e e.par) e.Pattern = <WeightPattern (<Add s.Weight 100>) e.Pt1 e.Pt2 e.Pattern>; */
    (s.Weight)(par e e.par) e.Pattern = <WeightPattern (s.Weight) e.Pattern>;
}

/* Вспомогательная для MinMGU. */
ChooseLeastMGU {
    ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2))'+' = (e.Pattern2)(e.Assignments2);
    ((e.Pattern1)(e.Assignments1))((e.Pattern2)(e.Assignments2))s.0 = (e.Pattern1)(e.Assignments1);
}

/*
    Функция назначения веса сопоставлений --- в доработке!
   ([Number])[MGUSub]^* => [Number]
*/
WeightMGU {
/* 0. Подстановки "символ - пустое множество" весят мало. */
    (e.Weight)e.Oth1 (assign (e.Var)()(s.Sym))e.Others =
     <WeightMGU (<Add e.Weight 1>)e.Oth1 e.Others>;
    (e.Weight)e.Oth1 (assign (e.Var)(s.Sym)())e.Others =
     <WeightMGU (<Add e.Weight 1>)e.Oth1 e.Others>;
/* 1. Расщепление каждой подстановки на две подстановки. */
    (e.Weight)(assign (e.Var)(e.Val1)(e.Val2))e.Others 
        = <WeightMGU (e.Weight)(assign (e.Var)(e.Val1))(assign (e.Var)(e.Val2))e.Others >;
/* 2. Прошлись по всем, посчитали. */
    (e.Weight) = e.Weight;
/* 3. Назначение параметру параметра того же типа --- хорошо. Это значит, были повторные подстановки. */
    (e.Weight)(assign (par s.type t.parname)((par s.type t.parname2)))e.Assignments 
        = <WeightMGU (<Sub e.Weight 10>) e.Assignments>;
/* 4. Назначение параметру выражения, с двух сторон окруженного е-параметрами. */
    (e.Weight)(assign (par e t.parname)((par e t.parname2)e.Expr(par e t.parname3)))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/* 5. Назначение параметру выражения, содержащего символ и е-параметр с краю (2 случая). */
    (e.Weight)(assign (par e t.parname)((par e t.parname2)e.Expr s.Sym))e.Assignments 
        = <WeightMGU (<Add e.Weight 20>) e.Assignments>;
    (e.Weight)(assign (par e t.parname)(s.Sym e.Expr (par e t.parname2)))e.Assignments 
        = <WeightMGU (<Add e.Weight 20>) e.Assignments>;
/* 6. Назначение параметру выражения, содержащего вызов. */
    (e.Weight)(assign (par e t.parname)((call e.call)))e.Assignments 
        = <WeightMGU (<Add e.Weight 5>) e.Assignments>;
/* 7. Назначение параметру выражения, содержащего s-параметр и е-параметр с краю (2 случая). */
    (e.Weight)(assign (par e t.parname)((par e t.parname2)e.Expr(par s t.sparname)))e.Assignments 
        = <WeightMGU (<Add e.Weight 15>) e.Assignments>;
    (e.Weight)(assign (par e t.parname)((par s t.sparname)e.Expr(par e t.parname2)))e.Assignments 
        = <WeightMGU (<Add e.Weight 15>) e.Assignments>;
/* 8. Назначение параметру выражения, содержащего t-параметр либо скобки и е-параметр с краю (2 случая). */
    (e.Weight)(assign (par e t.parname)((par e t.parname2)e.Expr t.Term))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
    (e.Weight)(assign (par e t.parname)(t.Term e.Expr(par e t.parname2)))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/* 9. Назначение параметру пустого выражения или символа (2 случая). */
    (e.Weight)(assign (par e t.parname)())e.Assignments 
        = <WeightMGU (<Add e.Weight 60>) e.Assignments>;    
    (e.Weight)(assign (par e t.parname)(s.Sym))e.Assignments 
        = <WeightMGU (<Add e.Weight 60>) e.Assignments>;    
/* 10. Назначение параметру параметра более узкого типа или выражения в скобках - 3 случая. */
    (e.Weight)(assign (par e t.parname)((par s t.sparname)))e.Assignments 
        = <WeightMGU (<Add e.Weight 30>) e.Assignments>;    
    (e.Weight)(assign (par e t.parname)(t.Term))e.Assignments 
        = <WeightMGU (<Add e.Weight 20>) e.Assignments>;    
    (e.Weight)(assign (par t t.parname)((par s t.sparname)))e.Assignments 
        = <WeightMGU (<Add e.Weight 5>) e.Assignments>;   
/* 11. Назначение t-параметру выражения в скобках либо символа. */
    (e.Weight)(assign (par t t.parname)(t.BracksOrSym))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/* 12. Назначение s-параметру символа. */	
    (e.Weight)(assign (par s t.parname)(s.Sym))e.Assignments 
        = <WeightMGU (<Add e.Weight 5>) e.Assignments>;    
/* 13. Назначение e-параметру выражения, содержащего хотя бы один вызов внутри. */	
    (e.Weight)(assign (par e t.parname)(e.Expr1 (call e.call) e.Expr2))e.Assignments 
        = <WeightMGU (<Add e.Weight 10>) e.Assignments>;
/* 14. Назначение e-параметру выражения, содержащего термы с двух сторон и е-параметр внутри. */	
    (e.Weight)(assign (par e t.parname)(e.Expr1 (par e t.parname) e.Expr2))e.Assignments 
        = <WeightMGU (<Add e.Weight 20>) e.Assignments>;
/* 15. Назначение e-параметру выражения, содержащего лишь объектные выражения либо вызовы. */	
    (e.Weight)(assign (par e t.parname)(e.Expr))e.Assignments 
        = <WeightMGU (<Add e.Weight 30>) e.Assignments>;
}/* WeightMGU */

