/* 
    Модуль разрешения квадратичных уравнений в словах.
   
   Экспортируемые функции:
   DecideQWESolvability --- разрешить вопрос о существовании корней квадратичного уравнения.
   (AreEqual ((s.Log1)([MultiSet])(e.LHS))((s.Log2)([MultiSet])(e.RHS))) => s.Log
   
*/

/* из модуля Generalize.ref */
$EXTERN HomeomorphicEmb;
/* из модуля WordEquations.ref */
$EXTERN IterateWEforPRTCs;
/* из модуля basics.ref */
$EXTERN MyZero, TermContradiction,Substitute, LogOr,LogAnd,RenewIndices,Collapse, LessGenericPattern, IsTerm;
/* из модуля accessMSCP.ref */
$EXTERN GetEBNewEqs,IsContradictory,GenerateNewEB,ReplaceEBNumericEqs,ReplaceEBNewEqs, GetEBNumericEqs;

/*
   $ENTRY Go {= <RenewIndices 'wevale_ind'><RenewIndices 'wevalt_ind'><Open 'w' 1 'buglog'>
	<Prout 
		<SolveEquation ()((weval e x)'a'(weval e x)) to ((weval e y)'a'(weval e y))>
	
	><Close 1>;} 
*/


/*
    Функция, разрешающая вопрос о наличии у квадратного уравнения корней.
   [WevalEquality] => s.Log
*/
$ENTRY DecideQWESolvability {
    t.Numeric (AreEqual (s.Log)(e.Pow1)(e.LHS)(e.Pow2)(e.RHS)),
    <Br 'SolveEqMode=1'> : e.1
        = <IfASolutionExists <SolveEquation t.Numeric (e.LHS) to (e.RHS)>>
        <Collapse <Dg 'SolveEqMode'><Br 'SolveEqMode=0'>>;
}

IfASolutionExists {
    (FinishedNode t.Node (True)) = 'T';
    (FinishedNode t.Node (Zero)) = 'F';
    (FinishedNode t.Node (Node Loop)) = 'F';
    (FinishedNode t.Node (e.Clash) (FinishedNode e.Child1) (FinishedNode e.Child2)(FinishedNode e.Child3))
        = <LogOr <LogOr <IfASolutionExists (FinishedNode e.Child1)><IfASolutionExists (FinishedNode e.Child2)>> <IfASolutionExists (FinishedNode e.Child3)>>;
    (FinishedNode t.Node (e.Clash) (FinishedNode e.Child1) (FinishedNode e.Child2)) 
        = <LogOr <IfASolutionExists (FinishedNode e.Child1)><IfASolutionExists (FinishedNode e.Child2)>>;
    (FinishedNode t.Node (e.Clash) (FinishedNode e.Child)) 
        = <IfASolutionExists (FinishedNode e.Child)>;
}

/*********************************************************
   КВАДРАТИЧНЫЕ УРАВНЕНИЯ
*********************************************************/


/* Прогонка для квадратичных уравнений. */
ClashQuadEquation {
/* 0. Левая и правая части полностью сопоставились. */
	(t.Node  t.NodeNumeric (() to ()))(e.Path) = (FinishedNode t.Node (True));
	(t.Node  t.NodeNumeric (((weval e t.Name)) to ()))(e.Path) = (FinishedNode t.Node (True));
	(t.Node  t.NodeNumeric (() to ((weval e t.Name))))(e.Path) = (FinishedNode t.Node (True));
/*
    	(t.Node (((weval e t.Name) e.LHS) to ((weval e t.Name) e.RHS)))(e.Path) = 
				<ClashQuadEquation (t.Node ((e.LHS) to (e.RHS)))(e.Path)>; 
*/

/* 1. Сопоставление двух переменных порождает расщепление на три варианта. */
	(t.Node t.NodeNumeric (((weval e t.Name) e.LHS) to ((weval e t.Name2) e.RHS)))(e.Path)
            = 
            (ProcessedNode t.Node t.NodeNumeric (((weval e t.Name) e.LHS) to ((weval e t.Name2) e.RHS))
            <ProcessNewNode (NewNode (assign (weval e t.Name) ((weval e t.Name2)(weval e t.Name))) 
                <ProcessNewQWERestriction  
                    (assign (weval e t.Name) ((weval e t.Name2)(weval e t.Name)))t.NodeNumeric
                    ((weval e t.Name) e.LHS) to ((weval e t.Name2) e.RHS)
                    >)(e.Path)>
            <ProcessNewNode (NewNode (assign (weval e t.Name2) ((weval e t.Name)(weval e t.Name2)))
                <ProcessNewQWERestriction 
                    (assign (weval e t.Name2) ((weval e t.Name)(weval e t.Name2))) t.NodeNumeric
                    ((weval e t.Name) e.LHS) to ((weval e t.Name2) e.RHS)
                    >)(e.Path)>
            <ProcessNewNode (NewNode (assign (weval e t.Name) ((weval e t.Name2))) 
                <ProcessNewQWERestriction 
                    (assign (weval e t.Name) ((weval e t.Name2))) t.NodeNumeric
                    ((weval e t.Name) e.LHS) to ((weval e t.Name2) e.RHS)
                    >)(e.Path)>);
/* 2. Сопоставление переменной и терма порождает расщепление на два варианта: переменная пуста, переменная содержит терм. */
	(t.Node t.NodeNumeric (((weval e t.Name) e.LHS) to (t.1 e.RHS)))(e.Path), 
        <TermContradiction (weval e t.Name) t.1> : 'F' 
            = 
            (ProcessedNode t.Node t.NodeNumeric (((weval e t.Name) e.LHS) to (t.1 e.RHS))
            <ProcessNewNode (NewNode (assign (weval e t.Name) (t.1(weval e t.Name))) 
                <ProcessNewQWERestriction  
                    (assign (weval e t.Name) (t.1(weval e t.Name))) t.NodeNumeric
                    ((weval e t.Name) e.LHS) to (t.1 e.RHS)
                >)(e.Path)>
            <ProcessNewNode (NewNode (assign (weval e t.Name) ()) 
                <ProcessNewQWERestriction  
                    (assign (weval e t.Name) ()) t.NodeNumeric
                    ((weval e t.Name) e.LHS) to (t.1 e.RHS)
                >)(e.Path)>);
	(t.Node t.NodeNumeric ((t.1 e.LHS) to ((weval e t.Name) e.RHS)))(e.Path),
        <TermContradiction (weval e t.Name) t.1> : 'F'        
            = 
            (ProcessedNode t.Node t.NodeNumeric((t.1 e.LHS) to ((weval e t.Name) e.RHS))
            <ProcessNewNode (NewNode (assign (weval e t.Name) (t.1(weval e t.Name))) 
                <ProcessNewQWERestriction 
                    (assign (weval e t.Name) (t.1(weval e t.Name))) t.NodeNumeric
                    (t.1 e.LHS) to ((weval e t.Name) e.RHS)
                >)(e.Path)>
            <ProcessNewNode (NewNode (assign (weval e t.Name) ())    
                <ProcessNewQWERestriction 
                    (assign (weval e t.Name) ())t.NodeNumeric
                    (t.1 e.LHS) to ((weval e t.Name) e.RHS)
                >)(e.Path)>);
/* 3. Два равных терма успешно сопоставляются. */
	(t.Node t.NodeNumeric ((t.1 e.LHS) to (t.1 e.RHS)))(e.Path)
            = <ClashQuadEquation (t.Node t.NodeNumeric ((e.LHS) to (e.RHS)))(e.Path)>;
/* 4. Термовая переменная, сопоставляемая с чем-нибудь ещё, порождает сужение, которое сразу же подставляется. */
        (t.Node t.NodeNumeric ((t.1 e.LHS) to (t.2 e.RHS)))(e.Path),
        <LogAnd <IsTerm t.1><IsTerm t.2>> :
        {'T',
            <LessGenericPattern t.1 t.2> :
            {'T' = 
/* <ClashQuadEquation 
                (t.Node 
                t.NodeNumeric 
                ((<Substitute (assign t.1 (t.2))>e.LHS) to (<Substitute (assign t.1 (t.2))>e.RHS)))(e.Path)
            >; 
*/
            (ProcessedNode 
                t.Node t.NodeNumeric 
                ((t.1 e.LHS) to (t.2 e.RHS))
                <ProcessNewNode (NewNode (assign t.1 (t.2)) 
					<ProcessNewQWERestriction  
						(assign t.1 (t.2)) t.NodeNumeric
						(t.1 e.LHS) to (t.2 e.RHS)
				>)(e.Path)>);
            'F' = 
/* <ClashQuadEquation 
                (t.Node 
                t.NodeNumeric 
                ((<Substitute (assign t.2 (t.1))>e.LHS) to (<Substitute (assign t.2 (t.1))>e.RHS)))(e.Path)
            >; 
*/
            (ProcessedNode 
                t.Node t.NodeNumeric
                ((t.1 e.LHS) to (t.2 e.RHS))
                <ProcessNewNode (NewNode (assign t.2 (t.1)) 
					<ProcessNewQWERestriction  
						(assign t.2 (t.1)) t.NodeNumeric
						(t.1 e.LHS) to (t.2 e.RHS)
				>)(e.Path)>);
            'NA' = (FinishedNode t.Node (Zero));
            };
        'F'
            = (FinishedNode t.Node (Zero));
        };
/*
    5. Если одна из частей уравнения пуста, а во второй первой стоит переменная, присваиваем ей пустое
   значение. Иначе конфигурация противоречива. 
*/
        (t.Node t.NodeNumeric ((t.1 e.LHS) to ()))(e.Path),
        t.1 :
        {(weval e t.Name)
            = (ProcessedNode
                t.Node t.NodeNumeric
                ((t.1 e.LHS) to ())
                <ProcessNewNode (NewNode (assign (weval e t.Name) ()) 
					<ProcessNewQWERestriction  
						(assign (weval e t.Name) ()) t.NodeNumeric
						((weval e t.Name) e.LHS) to ()
				>)(e.Path)>); 
/* <ClashQuadEquation 
                (t.Node 
                t.NodeNumeric 
                ((<Substitute (assign (weval e t.name) ())>e.LHS) to ()))(e.Path)
            >; 
*/
        t.2 
            = (FinishedNode t.Node (Zero));
        };
        (t.Node t.NodeNumeric (() to (t.1 e.RHS)))(e.Path),
        t.1 :
        {(weval e t.Name)
            = (ProcessedNode
                t.Node t.NodeNumeric
                (() to (t.1 e.RHS))
                <ProcessNewNode (NewNode (assign (weval e t.Name) ()) 
					<ProcessNewQWERestriction  
						(assign (weval e t.Name) ()) t.NodeNumeric
						() to ((weval e t.Name) e.RHS)
				>)(e.Path)>);
/* <ClashQuadEquation 
                (t.Node 
                t.NodeNumeric 
                (() to (<Substitute (assign (weval e t.name) ())>e.RHS)))(e.Path)
            >; 
*/
        t.2
            = (FinishedNode t.Node (Zero));
        };
}

/*
    Обработка нового присваивания на переменную --- подстановка его в правую и левую часть уравнения и удаление оттуда равных термов.
   (assign (weval e t.Name) t.Val)([Expr]) to ([Expr]) => (([Expr]) to ([Expr]))
*/
ProcessNewQWERestriction {
	(assign t.Name t.Val)(e.Numeric)(e.LHS) to (e.RHS)
            =
            (e.Numeric)
            (<DeleteEquals 
                (<Substitute ((assign t.Name t.Val))e.LHS>) 
                    to 
                (<Substitute ((assign t.Name t.Val))e.RHS>)
            >);
}

ProcessNewNode {
	(NewNode t.Name t.NodeNumeric t.Clash)(e.Path) 
            = <CheckNode4LoopBack ()(NewNode t.Name t.NodeNumeric t.Clash)((t.Name t.Clash) e.Path)>;
}

/*
    Удаление равных термов из двух выражений слева и справа.
   ([Expr]) to ([Expr]) => ([Expr]) to ([Expr])
*/
DeleteEquals {
	(t.1 e.1) to (t.1 e.2) = <DeleteEquals (e.1) to (e.2)>;
	(e.1 t.1) to (e.2 t.1) = <DeleteEquals (e.1) to (e.2)>;
	(e.1) to (e.2) = (e.1) to (e.2);
}

/* (e.Path)(e.Tree) => (e.ProcessedNode) */
ReturnNode {
    ((t.Name t.Clash))(t.NodeData t.Name t.Num t.Clash e.Children)e.Siblings
        =
        (ProcessedNode t.Name t.Num  t.Clash e.Children);
    ( e.Path (t.Name t.Clash))(ProcessedNode t.Name t.Num t.Clash e.Children)e.Siblings
        =
        <ReturnNode (e.Path) e.Children>;
    ( e.Path)(t.NodeData e.Data) e.Siblings 
        =
        <ReturnNode (e.Path) e.Siblings>;
}

/* (ProcessedNode t.Name e.Data)(e.Path)e.Tree => e.NewTree */
SubstituteLeaf {
    (t.NodeInfo t.Name e.Data)((t.Name t.Clash))(t.NodeInfo2 t.Name e.Data2) e.Siblings 
        = 
        (t.NodeInfo t.Name e.Data) e.Siblings;
		
    t.Leaf (e.Path(t.Name t.Clash))(ProcessedNode t.Name t.Num t.Clash e.Children)e.Siblings
        =
        (ProcessedNode t.Name t.Num t.Clash <SubstituteLeaf t.Leaf (e.Path) e.Children>) e.Siblings;
		
    t.Leaf (e.Path)(t.NodeInfo e.Data) e.Siblings
        =
        (t.NodeInfo e.Data) <SubstituteLeaf t.Leaf (e.Path) e.Siblings>;
}

/* Проверка, является ли вершина финальной. Если не финальная, возвращаем незавершенный лист. */
CheckNodeStatus {
	(e.FinChildren)(t.NodeInfo t.Name t.Num t.Clash) = ()(FinishedNode t.Name t.Clash e.FinChildren);
        (e.FinChildren)(t.NodeInfo t.Name t.Clash) = ()(FinishedNode t.Name t.Clash e.FinChildren);
	(e.FinChildren)(t.NodeInfo t.Name t.Num t.Clash (FinishedNode e.Child)e.C)
            = 
            <CheckNodeStatus (e.FinChildren (FinishedNode e.Child))(t.NodeInfo t.Name t.Num t.Clash e.C)>;
	(e.FinChildren)(t.NodeInfo t.Name t.Num  t.Clash (t.NotFinished e.Child)e.C)
            = 
            (t.NotFinished e.Child)(ProcessedNode t.Name t.Num  t.Clash e.FinChildren (t.NotFinished e.Child) e.C);		
}


FindActiveNode {
	(e.Node)(e.Path)e.Tree = <FindActiveNodeAux <CheckNodeStatus ()(e.Node)>(e.Path)e.Tree>;
}

/* Поиск "ближайшей" активной (нефинальной) вершины. */
FindActiveNodeAux {
/* 1. Вычисления завершены в корневой вершине. */
    ()(FinishedNode t.NodeName e.NodeData)((t.NodeName e.NodeClash)) e.Tree 
        = (FinishedNode t.NodeName e.NodeData)((t.NodeName e.NodeClash))
            <SubstituteLeaf 
                (FinishedNode t.NodeName e.NodeData)
                ((t.NodeName e.NodeClash))
                e.Tree
            >;

/* 2. Вычисления завершены в некорневой вершине - проверяем на предмет незавершенных вычислений её родительской вершины. */
    ()(FinishedNode t.NodeName e.NodeData)((t.NodeName e.NodeClash) t.ParentNode e.Path) e.Tree 
            = <FindActiveNode 
                <ReturnNode (t.ParentNode e.Path) <SubstituteLeaf 
                    (FinishedNode t.NodeName e.NodeData)
                    ((t.NodeName e.NodeClash) t.ParentNode e.Path)
                    e.Tree
                >>
                (t.ParentNode e.Path) 
                <SubstituteLeaf 
                    (FinishedNode t.NodeName e.NodeData)
                    ((t.NodeName e.NodeClash) t.ParentNode e.Path)
                    e.Tree
                >
            >;
/* 3. У вершины имеется невычисленный потомок - переходим к нему. */
    (t.NotFinished t.ChildName t.Num t.ClashChild e.Child)
    (ProcessedNode e.Node)(e.Path)e.Tree
        = 
        (t.NotFinished t.ChildName t.Num t.ClashChild e.Child)
        ((t.ChildName t.ClashChild)e.Path)
        <SubstituteLeaf 
            (ProcessedNode e.Node)
            (e.Path)
            e.Tree
        >;
}

/* Проверка, является ли вершина повторной на пути. */
CheckNode4LoopBack {
	()(FinishedNode e.Data)(e.Path) = (FinishedNode e.Data);
	()(e.Leaf)(t.Branch e.Path) = <CheckNode4LoopBack (t.Branch)(e.Leaf)(e.Path)>;
	(e.Path)(e.Leaf)() = (e.Leaf);
	(e.LowerPath)(t.Status t.NodeName t.NodeNumeric ((e.LHS1) to (e.RHS1)) e.Other)
        ((t.NodeName2 ((e.LHS2) to (e.RHS2))) e.UpperPath),
        <HomeomorphicEmb (e.LHS2)e.LHS1> : 'T',
        <HomeomorphicEmb (e.RHS2)e.RHS1> : 'T'
            = 
            (FinishedNode t.NodeName (Node Loop));
	(e.LowerPath)(e.Leaf)(t.Branch e.UpperPath)
            = 
            <CheckNode4LoopBack (e.LowerPath t.Branch)(e.Leaf)(e.UpperPath)>;
}


UnfoldEquation {
    t.NumBlock(NewNode e.Node)(e.Path)e.Tree 
        = <Unf4QEAux t.NumBlock  
            <CheckNode4LoopBack ()(NewNode e.Node)(e.Path)>
            (e.Path)
            e.Tree
        >;
    t.NumBlock(e.Leaf)(e.Path)e.Tree 
        = <Unf4QEAux t.NumBlock 
            <FindActiveNode 
                <CheckNode4LoopBack ()(e.Leaf)(e.Path)>
                (e.Path)
                e.Tree
            >>;
}

Unf4QEAux {
    t.NumBlock (FinishedNode t.NodeName e.NodeData)(e.Path)e.Tree = e.Tree;
    (e.NumBlock) (t.Status t.Name (e.NumNode)((e.LHS) to (e.RHS)) e.Other)(e.Path)e.Tree,
    <GenerateNewEB> : t.FreshEqBlock,
    <ReplaceEBNumericEqs 
        <ReplaceEBNewEqs 
            t.FreshEqBlock (AreEqual ('T')()(e.LHS)()(e.RHS))>
            e.NumBlock
    > : t.CurrentEqData
/* <IterateWEforPRTCs t.CurrentEqData> : t.NewEqBlock */
            = <Putout 1 'Simple solving:'>
            <Putout 1 t.CurrentEqData>
            <UnfoldEquation ()
                <Check4Consistency t.Name t.CurrentEqData (e.Path)
                >
                (e.Path)e.Tree
            >;
/*
    Порождается больше, чем одна непротиворечивая конфигурация при базовом разборе уравнения -
   пока игнорируем эту информацию и просто применяем сопоставление. 
*/

    /*    (e.NumBlock) (t.Status t.Name ((e.LHS) to (e.RHS)) e.Other)(e.Path)e.Tree =
            <UnfoldEquation 
                ()
                <ClashQuadEquation (t.Name (e.NumBlock)((e.LHS) to (e.RHS)))(e.Path)> (e.Path)e.Tree
            >; 
*/

}

Check4Consistency {
	t.NodeName t.EqBlock (e.Path),
        <IsContradictory t.EqBlock> : 'T' 
            = (FinishedNode t.NodeName (Zero));
/*
    	t.Node (e.Clash)(e.Path)(e.Assignments)((AreEqual (e.ParMS1)(e.Proc1)(e.ParMS2)(e.Proc2)))('T')= 
		<ClashQuadEquation (t.Node(<DeleteEquals (e.Proc1) to (e.Proc2)>))(e.Path)>; 
*/

	t.NodeName t.EqBlock (e.Path),
        <GetClashFromEquations (() to ())<GetEBNewEqs t.EqBlock>> : e.Clash,
        <GetEBNumericEqs t.EqBlock> : e.numeric
            = <ClashQuadEquation (t.NodeName (e.numeric) (e.Clash))(e.Path)>;
}

GetClashFromEquations {
        (e.Clash) = e.Clash;
        ((e.LHS) to (e.RHS))(AreEqual (s.Log)t.MS1 (e.ELHS)t.MS2 (e.ERHS)) e.Other
            = <GetClashFromEquations ((e.LHS e.ELHS) to (e.RHS e.ERHS)) e.Other>;
}

SolveEquation {
	(e.Numeric)(e.LHS) to (e.RHS)
            = <UnfoldEquation 
                (e.Numeric)
                (NewNode Root ()((e.LHS) to (e.RHS)))
                ((Root ((e.LHS) to (e.RHS))))
                (NewNode Root ()((e.LHS) to (e.RHS)))
            >; 
}
