<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1251">
	<TITLE> MSCP-A: examples </TITLE>
<!--	<STYLE TYPE="text/css">
	</STYLE>
-->
</HEAD>
<!-- <BODY LANG="ru-RU" TEXT="#000000" BGCOLOR="#ffffff" BACKGROUND="fon.gif" DIR="LTR"> -->
<body bgproperties="fixed" text="#000000" bgcolor="#FFFFFF" background="fon.gif">
  <a name="TopOfFile"></a>
  <p valign="middle" align="center">
  
</p><hr>

<HR>
<H2><U>MSCP: examples of the supercompilation </U>
</H2>
<P><B>How to understand the examples?</B></P>
<UL>
	<LI>A <a href="http://refal.botik.ru/book/html/">Refal</a> function definition is a list of rewrite rules. 
        The rewrite rules use the three types of variables:
	e-variables can be associated with an arbitrary expression;
	t-variables can be associated with a symbol or an expression (e.x),
	where e.x is arbitrary; s-variables can be associated only with a
	symbol. 


<LI> The associative concatenation ++ is built-in, thus i.e. we
	understand the pattern e.x s.y as e.x ++ s.y. A call of the function
	F on the argument Expr is written as &lt;F Expr&gt;.       
<LI>
 We say that the supercompiler proves a statement if the input program computes some predicate and in the residual program all the
outputs have the same truth value. That means the semantic property of the input program becomes the syntactic property of the residual one. 
	
</UL>
<HR>
<H3>Example list:</H3>
<TABLE WIDTH=60% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD WIDTH=50%>
			<UL>
				<LI><A HREF="#Fabc">Fabc</A>                                    <!-- 1 -->
				<LI><A HREF="#FabcFin">Fabc (finite alphabet)</A> 
				<LI><A HREF="#SqSum">SqSum </A>
				<LI><A HREF="#Fib">Fibonacci</A> 
				<LI><A HREF="#Prefix">Prefix</A> 
				<LI><A HREF="#Prefix2">Prefix2</A> 
				<LI><A HREF="#PrefixA">Prefix of A's</A> 
				<LI><A HREF="#PrefixPlusAB">Prefix plus AB</A> 
				<LI><A HREF="#EqsAsRestr">Equations as a condition</A>
				<LI><A HREF="#RecProtocolCorr">Correct protocol with a loop</A> <!-- 10 -->

				<LI><A HREF="#RecProtocolInc">Incorrect protocol  with a loop</A> <!-- 11 -->
				<LI><A HREF="#eqlemmas">Pushing equations while	generalizing </A>
				<LI><A HREF="#Fabr_sym">More pushing equations	while generalizing </A>
				<LI><A HREF="#FibWord">Proving properties of Fibonacci words </A>
				<LI><A HREF="#unused">Generalization of negative restrictions </A>
				<LI><A HREF="#AB_tail">Correct exhaustive deletion v.1 </A>
				<LI><A HREF="#ABmoved">Correct exhaustive deletion v.2 </A>       <!-- 17 -->
			</UL>
		</TD>
		<TD WIDTH=50%>
			<UL>
				<LI><A HREF="#CheckB">CheckForB</A>      <!-- 18 -->
				<LI><A HREF="#CheckB2">CheckForB variant</A> 
				<LI><A HREF="#Look">WordEq</A>           <!-- 20 -->

				<LI><A HREF="#Order">InfCall</A>         <!-- 21 -->
				<LI><A HREF="#PalAB">PalAB</A> 
				<LI><A HREF="#BAincorrect">Not only 'A'-s</A> 
				<LI><A HREF="#Singapore">Trinh et al test</A> 
				<LI><A HREF="#Sweden">Abdulla et al test</A> 
				<LI><A HREF="#OpenVar">Open vars test</A> 
				<LI><A HREF="#NonQuad">Non-quadratic equation</A> 
				<LI><A HREF="#ScriptScript">Incorrect sanitization</A>
				<LI><A HREF="#ScriptIp">Correct sanitization - ip</A>  
				<LI><A HREF="#ScriptBrackets">Correct sanitization - brackets</A> <!-- 30 -->

				<LI><A HREF="#ScriptIpNB">Correct sanitization - ip and no blanks</A> <!-- 31 -->
				<LI><A HREF="#ScriptSilly">Correct but silly sanitization</A> 
				<LI><A HREF="#scriptComplex">Guarnieri et al test</A> 
				<LI><A HREF="#finiteletter">Square subword</A> 
				<LI><A HREF="#KMPtest">Naive matching to KMP</A>                  <!-- 35 -->
			</UL>
		</TD>
	</TR>
</TABLE>
<HR>
<P><A NAME="Fabc"></A><B>Example #1 (Fabc):</B></P>
<P><A HREF="test_web_eng/test_Fabc.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>A simple test: merging two loops in a one. &nbsp; 
	
</UL>
<HR>
<P><A NAME="FabcFin"></A><B>Example #2 (Fabc (finite alphabet)):</B></P>
<P><A HREF="test_web_eng/test_Fabc_finalph.ref">The input and residual programs</A>
</P>
<UL>
	<LI>A simple test: merging two loops in a one in the
	alphabet {A,B,C}. &nbsp; 
	
</UL>
<HR>
<P><A NAME="SqSum"></A><B>Example #3 (SqSum):</B></P>
<P><A HREF="test_web_eng/test_SqSum.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>The function computing a square sum in the Peano
	arithmetic takes a partially defined value as an argument. The
	definitions of the sum and the multiplication use associativity of
	the language. 
	
</UL>
<HR>
<P><A NAME="Fib"></A><B>Example #4 (Fibonacci):</B></P>
<P><A HREF="test_web_eng/test_fib.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>The function computing the n-th Fibonacci number
	takes a partially defined value as an argument. 
	
</UL>
<HR>
<P><A NAME="Prefix"></A><B>Example #5 (Prefix):</B></P>
<P><A HREF="test_web_eng/test_prefix.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>The test of the equivalence of the two concatenation
	definitions. 
	
</UL>
<HR>
<P><A NAME="Prefix2"></A><B>Example #6 (Prefix2):</B></P>
<P><A HREF="test_web_eng/test_strangeprefix.ref">The input and the residual
program</A> 
</P>
<UL>
	<LI>The test of the equivalence of the two other
	concatenation definitions. 
	
</UL>
<HR>
<P><A NAME="PrefixA"></A><B>Example #7 (Prefix of A's):</B></P>
<P><A HREF="test_web_eng/test_PrefixA.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>In what cases the string x is a prefix of 'A'++x++y?
	Appending is done by the built-in concatenation. 
	
</UL>
<HR>
<P><A NAME="PrefixPlusAB"></A><B>Example #8 (Prefix Plus AB):</B></P>
<P><A HREF="test_web_eng/test_ABplusPrefix.ref">The input and residual programs</A>
</P>
<UL>
	<LI>In what cases the string x is a prefix of
	'AB'++x++y? Appending of y is done in a loop processing a string
	from its end. 
	
</UL>
<HR>
<P><A NAME="EqsAsRestr"></A><B>Example #9 (Equations as a
condition):</B></P>
<P><A HREF="test_web_eng/test_eqsASrestr.ref">The input and residual programs</A>
</P>
<UL>
	<LI>A word equation is given explicitly. It is used
	during the unfolding. 
	
</UL>
<HR>
<P><A NAME="RecProtocolCorr"></A><B>Example #10 (Correct protocol
with a loop):</B></P>
<P><A HREF="test_web_eng/test_ProtoSafe.ref">The input and residual programs</A>
</P>
<UL>
	<LI>Verification of a safe protocol taken from the paper
	D. Beyer, M. Dangl, P. Wendler. Boosting k-Induction with Continuously-Refined Invariants // 
 In: Kroening D., Pasareanu C. (eds) Computer Aided Verification. CAV 2015. / LNCS, Vol. 9206, pp: 622-640. Springer, 2015. 
	
</UL>
<HR>
<P><A NAME="RecProtocolInc"></A><B>Example #11 (Incorrect protocol
with a loop):</B></P>
<P><A HREF="test_web_eng/test_ProtoUnsafe.ref">The input and residual programs</A>
</P>
<UL>
	<LI>Finding a counterexample to an unsafe protocol taken
	from the paper D. Beyer, M. Dangl, P. Wendler. Boosting k-Induction with Continuously-Refined Invariants // 
 In: Kroening D., Pasareanu C. (eds) Computer Aided Verification. CAV 2015. / LNCS, Vol. 9206, pp: 622-640. Springer, 2015.
	
</UL>
<HR>
<P><A NAME="eqlemmas"></A><B>Example #12 (Pushing equations while
generalizing):</B></P>
<P><A HREF="test_web_eng/test_eqlemmas0.ref">The input and residual programs</A>
</P>
<UL>
	<LI>A test on using the word equations in constructing
	generalizations of expressions. 
	
</UL>
<HR>
<P><A NAME="Fabr_sym"></A><B>Example #13 (More using equations while
generalizing ):</B></P>
<P><A HREF="test_web_eng/test_Fabr.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>Another test on using word equations in
	generalization. 
	
</UL>
<HR>
<P><A NAME="FibWord"></A><B>Example #14 (Proving properties of
Fibonacci words):</B></P>
<P><A HREF="test_web_eng/test_FibWord.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>After two iterations of the supercompilation, a
	property of the Fibonacci words is proven. 
	
</UL>
<HR>
<P><A NAME="unused"></A><B>Example #15 (Generalization of negative
restrictions ):</B></P>
<P><A HREF="test_web_eng/test_unused.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>A negative restriction on a symbol is generalized to
	a negative restriction on an expression. 
	
</UL>
<HR>
<P><A NAME="AB_tail"></A><B>Example #16 (Exhaustive deletion 1 ):</B></P>
<P><A HREF="test_web_eng/test_AB_tail.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>A correct version of the exhaustive deletion algorithm. 
	
</UL>
<HR>
<P><A NAME="ABmoved"></A><B>Example #17 (Exhaustive deletion 2 ):</B></P>
<P><A HREF="test_web_eng/test_ABmoved.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>Another correct version of the exhaustive deletion. 
	
</UL>
<HR>
<P><A NAME="CheckB"></A><B>Example #18 (CheckForB)</B></P>
<P><A HREF="test_web_eng/test_ba1.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>Given a function generating a string in the language
	'A'*, the task is to check the last letter of the string is never
	'B'. 
	
</UL>
<HR>
<P><A NAME="CheckB2"></A><B>Example #19 (CheckForB2)</B></P>
<P><A HREF="test_web_eng/test_ba2.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>Given a function generating a string in the language
	'A'*, the task is to check the last letter of the string never
	contains 'B'. 
	
</UL>
<HR>
<P><A NAME="Look"></A><B>Example #20 (Word Equations)</B></P>
<P><A HREF="test_web_eng/test_look.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>Existence of the multiple t-variables in the pattern
	may lead to an equation generation. 
	
</UL>
<HR>
<P><A NAME="Order"></A><B>Example #21 (InfCall)</B></P>
<P><A HREF="test_web_eng/test_order.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>The normal computation order on the associative data
	may lead to non-trivial function order in a stack. 
	
</UL>
<HR>
<P><A NAME="PalAB"></A><B>Example #22 (PalAB)</B></P>
<P><A HREF="test_web_eng/test_palplusAB.ref">The input and residual programs</A>
</P>
<UL>
	<LI>If we append the prefix 'AB' to the
	string and then append its inversion, we can never get a palindrome.
		
</UL>
<HR>
<P><A NAME="BAincorrect"></A><B>Example #23 (Not only 'A'-s):</B></P>
<P><A HREF="test_web_eng/test_ba_incorrect.ref">The input and residual programs</A>
</P>
<UL>
	<LI>A simple test on removing refuted hypotheses after a
	generalization. First, the hypothesis of belonging to the laguage A*
	is generated. When the next generalization attempt is done, it is
	refuted. 
	
</UL>
<HR>
<P><A NAME="Singapore"></A><B>Example #24 (Thinh et al test):</B></P>
<P><A HREF="test_web_eng/test_Singapore.ref">The input and residual programs</A>
</P>
<UL>
	<LI>The test from the paper: M.T Trinh, D.H Chu, J.
	Jaffar, Progressive reasoning over recursively-defined strings /
	International Conference on Computer Aided Verification, 2016,
	218-240.<!-- Progressive Reasoning over Recursively-Defined Strings / M.T.Trinh et al -->
		
</UL>
<HR>
<P><A NAME="Sweden"></A><B>Example #25 (Abdulla et al test):</B></P>
<P><A HREF="test_web_eng/test_Sweden.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>The test from the paper: Parosh Aziz Abdulla,
	Mohamed Faouzi Atig, Yu-Fang Chen, Bui Phi Diep, Lukas Holik, Ahmed
	Rezine, Philipp Rummer. Flatten and conquer: a framework for
	efficient analysis of string constraints, Programming Language
	Design and Implementation (PLDI), 2017, Barcelona, Spain, ACM, pages
	602-617.<!-- Flatten and Conquer. A Framework for Efficient Analysis of String Constraints / P.A.Abdulla et al. -->
		
</UL>
<HR>
<P><A NAME="OpenVar"></A><B>Example #26 (Open variables test):</B></P>
<P><A HREF="test_web_eng/test_openvars.ref">The input and residual programs</A>
</P>
<UL>
	<LI>A test on processing open variables in patterns. 
	
</UL>
<HR>
<P><A NAME="NonQuad"></A><B>Example #27 (Non-quadratic equations
test):</B></P>
<P><A HREF="test_web_eng/test_nonquadratic.ref">The input and residual programs</A>
</P>
<UL>
	<LI>Given a non-quadratic equation, the supercompiler
	manages to solve it combining elementary actions. 
	
</UL>
<HR>
<P><A NAME="ScriptScript"></A><B>Example #28 (Incorrect
sanitization):</B></P>
<P><A HREF="test_web_eng/test_Script1.ref">The input and residual programs</A>
</P>
<UL>
	<LI>A simple sanitization algorithm is shown to be
	incorrect. 
	
</UL>
<HR>
<P><A NAME="ScriptIp"></A><B>Example #29 (Correct sanitization - ip):</B></P>
<P><A HREF="test_web_eng/test_Script.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>The test is taken from the paper: M.T Trinh, D.H
	Chu, J. Jaffar, Progressive reasoning over recursively-defined
	strings / International Conference on Computer Aided Verification,
	2016, 218-240. 

A sanitization algorithm is shown to be correct in
	respect with the given conditions. 
	
</UL>
<HR>
<P><A NAME="ScriptBrackets"></A><B>Example #30 (Correct sanitization
- brackets):</B></P>
<P><A HREF="test_web_eng/test_Script2.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>The test is taken from the paper: M.T Trinh, D.H
	Chu, J. Jaffar, Progressive reasoning over recursively-defined
	strings / International Conference on Computer Aided Verification,
	2016, 218-240. 

A sanitization algorithm is also shown to be correct
	in respect with the given conditions. 
	
</UL>
<HR>
<P><A NAME="ScriptIpNB"></A><B>Example #31 (Correct sanitization - ip
and no blanks):</B></P>
<P><A HREF="test_web_eng/test_Script3.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>A modified version of the test #30. 
	
</UL>
<HR>
<P><A NAME="ScriptSilly"></A><B>Example #32 (Correct but silly
sanitization):</B></P>
<P><A HREF="test_web_eng/test_script0.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>A simple sanitization algorithm is shown to be
	correct. 
	
</UL>
<HR>
<P><A NAME="scriptComplex"></A><B>Example #33 (Guarnieri et al test):</B></P>
<P><A HREF="test_web_eng/test_scriptComplex.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>The test is taken from the paper

 Guarnieri, M. Pistoia, O. Tripp, Ju. Dolby, S. Teilhet, R. Berg. Saving the World Wide Webfrom Vulnerable JavaScript // 
In: Proceedings of the 2011 International Symposium on Software Testing and Analysis (ISSTA '11), pp: 177-187, 2011

A sanitization of the innertext method. 
	
</UL>
<HR>
<P><A NAME="finiteletter"></A><B>Example #34 (Square subword):</B></P>
<P><A HREF="test_web_eng/test_finiteletter.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>Proving that every word in the alphabet {'A', 'B'} has a square subword. 
	
</UL>
<HR>
<P><A NAME="KMPtest"></A><B>Example #35 (Naive matching to KMP):</B></P>
<P><A HREF="test_web_eng/test_KMPtest.ref">The input and residual programs</A> 
</P>
<UL>
	<LI>A version of the classical supercompiler test for the associative data type. 
	
</UL>
</BODY>
</HTML>
