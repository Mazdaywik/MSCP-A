<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1251">
	<TITLE> MSCP-A: examples </TITLE>
</HEAD>
<body bgproperties="fixed" text="#000000" bgcolor="#FFFFFF" background="fon.gif">
  <a name="TopOfFile"></a>
  <p valign="middle" align="center">
  
</p><hr>

<HR>
<H2><U>MSCP-A: examples of the supercompilation </U>
</H2>
<P><B>How to understand the examples?</B></P>
<UL>
	<LI>A <a href="http://refal.botik.ru/book/html/">Refal</a> function definition is a list of rewrite rules. 
        The rewrite rules use the three types of variables:
	e-variables can be associated with an arbitrary expression;
	t-variables can be associated with a symbol or an expression <code>(e.x)</code>,
	where <code>e.x</code> is arbitrary; s-variables can be associated only with a symbol. 


<LI>  The associative concatenation <code>++</code> is built-in, thus i.e. we
	understand the pattern <code>e.x s.y</code> as <code>e.x ++ s.y</code>. A call of the function
	<code>F</code> on the argument <code>Expr</code> is written as <code>&lt;F Expr&gt;</code>.        
<LI> 
 We say that the supercompiler proves a statement if the input program computes some predicate and in the residual program all the
outputs have the same truth value. That means the semantic property of the input program becomes the syntactic property of the residual one.  
	
</UL>
<HR>
<H3 CLASS="western">Example list:</H3>
<TABLE WIDTH=60% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD WIDTH=30%>
			<UL>
				<LI><A HREF="#Fabc">Fabc</A>                                    <!-- 1 -->
				<LI> <A HREF="#FabcFin">Fabc (finite alphabet)</A> 
				<LI> <A HREF="#SqSum">SqSum </A>
				<LI> <A HREF="#Fib">Fibonacci</A> 
				<LI> <A HREF="#Prefix">Prefix</A> 
				<LI> <A HREF="#Prefix2">Prefix2</A> 
				<LI> <A HREF="#PrefixA">Prefix of A's</A> 
				<LI> <A HREF="#PrefixPlusAB">Prefix plus AB</A> 
				<LI> <A HREF="#EqsAsRestr">Equations as a condition</A>
				<LI><A HREF="#RecProtocolCorr">Correct protocol with a loop</A> <!-- 10 -->

				<LI><A HREF="#RecProtocolInc">Incorrect protocol  with a loop</A> <!-- 11 -->
				<LI> <A HREF="#eqlemmas">Pushing equations while generalizing </A>
				<LI> <A HREF="#Fabr_sym">More pushing equations	while generalizing </A>
				<LI> <A HREF="#FibWord">Proving properties of Fibonacci words </A>
				<LI> <A HREF="#unused">Generalization of negative restrictions </A>
				<LI> <A HREF="#AB_tail">Correct exhaustive deletion v.1 </A>
				<LI> <A HREF="#ABmoved">Correct exhaustive deletion v.2 </A>  <!-- 17 -->
				<LI> <A HREF="#CheckB">CheckForB</A> 
				<LI> <A HREF="#CheckB2">CheckForB variant</A> 
				<LI> <A HREF="#Look">WordEq</A>                  <!-- 20 -->

				<LI> <A HREF="#Order">InfCall</A>                <!-- 21 -->
			</UL>
		</TD>
		<TD WIDTH=30%>
			<UL>
				<LI> <A HREF="#PalAB">PalAB</A>                  <!-- 22 -->
				<LI> <A HREF="#BAincorrect">Not only 'A'-s</A> 
				<LI> <A HREF="#Singapore">Trinh et al test</A> 
				<LI> <A HREF="#Sweden">Abdulla et al test</A> 
				<LI> <A HREF="#OpenVar">Open vars test</A> 
				<LI> <A HREF="#NonQuad">Non-quadratic equation</A> 
				<LI> <A HREF="#ScriptScript">Incorrect sanitization</A>
				<LI> <A HREF="#ScriptIp">Correct sanitization &ndash; ip</A>
				<LI> <A HREF="#ScriptIpNB">Correct sanitization &ndash; ip and no blanks</A> 
				<LI> <A HREF="#ScriptBrackets">Correct sanitization &ndash; brackets</A>     <!-- 32 -->

				<LI> <A HREF="#ScriptSilly">Correct but silly sanitization</A>         <!-- 33 -->
				<LI> <A HREF="#scriptComplex">Guarnieri et al test</A> 
				<LI> <A HREF="#finiteletter">Square subword</A> 
				<LI> <A HREF="#KMPtest">Naive matching to KMP</A> 
				<LI> <A HREF="#sumcomm">Commutativity of the associative addition</A> 
				<LI> <A HREF="#RefalMachine">Interpreter of Zip function </A>
				<LI> <A HREF="#weqs_int_base_new">Word equation interpreter specialized w.r.t. xAy=yBx </A>
				<LI> <A HREF="#weqs_int_base_1">Word equation interpreter specialized w.r.t. ABxy = xyBA </A>
				<LI> <A HREF="#weqs_int_base_2">Word equation interpreter specialized w.r.t. xAy = zzz </A>
				<LI> <A HREF="#weqs_int_base_3">Word equation interpreter specialized w.r.t. zAByx = yzxBA </A>   <!-- 43 -->
			</UL>
		</TD>
		<TD>
			<UL>
<!--        			<LI> Follow <a href="../../we_interpreters/weq_int_readme_local.html">this link</a> -->
        			<LI> Follow <a href="./weq_int_readme.html">this link</a> 
                                     for the experiments on specialization of the word equation interpreters by the supercompiler SCP4.
			</UL>
		</TD>
	</TR>
</TABLE>
<HR>
<P><A NAME="Fabc"></A><B>Example #1 (Fabc):</B></P>
<P><A HREF="test_web_eng/test_Fabc.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> A simple test: merging two loops in a one. &nbsp; 
	 
</UL>
<HR>
<P><A NAME="FabcFin"></A><B>Example #2 (Fabc (finite alphabet)):</B></P>
<P><A HREF="test_web_eng/test_Fabc_finalph.ref">The input and the residual program</A>
</P>
<UL>
	<LI> A simple test: merging two loops in a one in the
	alphabet {A,B,C}. &nbsp; 
	 
</UL>
<HR>
<P><A NAME="SqSum"></A><B>Example #3 (SqSum):</B></P>
<P><A HREF="test_web_eng/test_SqSum.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The function computing a square sum in the Peano
	arithmetic takes a partially defined value as an argument. 
        The definitions of the sum and the multiplication use associativity of the language. 
	 
</UL>
<HR>
<P><A NAME="Fib"></A><B>Example #4 (Fibonacci):</B></P>
<P><A HREF="test_web_eng/test_fib.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The function computing the n-th Fibonacci number
	takes a partially defined value as an argument. 
	 
</UL>
<HR>
<P><A NAME="Prefix"></A><B>Example #5 (Prefix):</B></P>
<P><A HREF="test_web_eng/test_prefix.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The test of the equivalence of the two concatenation definitions. 
	 
</UL>
<HR>
<P><A NAME="Prefix2"></A><B>Example #6 (Prefix2):</B></P>
<P><A HREF="test_web_eng/test_strangeprefix.ref">The input and the residual
program</A> 
</P>
<UL>
	<LI> The test of the equivalence of the two other concatenation definitions. 
	 
</UL>
<HR>
<P><A NAME="PrefixA"></A><B>Example #7 (Prefix of A's):</B></P>
<P><A HREF="test_web_eng/test_PrefixA.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> In what cases the string x is a prefix of 'A'++x++y?
	Appending is done by the built-in concatenation. 
	 
</UL>
<HR>
<P><A NAME="PrefixPlusAB"></A><B>Example #8 (Prefix Plus AB):</B></P>
<P><A HREF="test_web_eng/test_ABplusPrefix.ref">The input and the residual program</A>
</P>
<UL>
	<LI> In what cases the string x is a prefix of
	'AB'++x++y? Appending of y is done in a loop processing a string from its end. 
	 
</UL>
<HR>
<P><A NAME="EqsAsRestr"></A><B>Example #9 (Equations as a
condition):</B></P>
<P><A HREF="test_web_eng/test_eqsASrestr.ref">The input and the residual program</A>
</P>
<UL>
	<LI> A word equation is given explicitly. It is used during the unfolding. 
	 
</UL>
<HR>
<P><A NAME="RecProtocolCorr"></A><B>Example #10 (Correct protocol with a loop):</B></P>
<P><A HREF="test_web_eng/test_ProtoSafe.ref">The input and the residual program</A>
</P>
<UL>
	<LI> Verification of a safe protocol taken from the paper
	D. Beyer, M. Dangl, P. Wendler. Boosting k-Induction with Continuously-Refined Invariants // 
 In: Kroening D., Pasareanu C. (eds) Computer Aided Verification. CAV 2015. / LNCS, Vol. 9206, pp: 622-640. Springer, 2015. 
	 
</UL>
<HR>
<P><A NAME="RecProtocolInc"></A><B>Example #11 (Incorrect protocol
with a loop):</B></P>
<P><A HREF="test_web_eng/test_ProtoUnsafe.ref">The input and the residual program</A>
</P>
<UL>
	<LI> Finding a counterexample to an unsafe protocol taken
	from the paper D. Beyer, M. Dangl, P. Wendler. Boosting k-Induction with Continuously-Refined Invariants // 
 In: Kroening D., Pasareanu C. (eds) Computer Aided Verification. CAV 2015. / LNCS, Vol. 9206, pp: 622-640. Springer, 2015.
	 
</UL>
<HR>
<P><A NAME="eqlemmas"></A><B>Example #12 (Pushing equations while generalizing):</B></P>
<P><A HREF="test_web_eng/test_eqlemmas0.ref">The input and the residual program</A>
</P>
<UL>
	<LI> A test on using the word equations in constructing generalizations of expressions. 
	 
</UL>
<HR>
<P><A NAME="Fabr_sym"></A><B>Example #13 (More using equations while generalizing ):</B></P>
<P><A HREF="test_web_eng/test_Fabr.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> Another test on using word equations in generalization. 
	 
</UL>
<HR>
<P><A NAME="FibWord"></A><B>Example #14 (Proving properties of Fibonacci words):</B></P>
<P><A HREF="test_web_eng/test_FibWord.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> After two iterations of the supercompilation, a property of the Fibonacci words is proven. 
	 
</UL>
<HR>
<P><A NAME="unused"></A><B>Example #15 (Generalization of negative restrictions ):</B></P>
<P><A HREF="test_web_eng/test_unused.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> A negative restriction on a symbol is generalized to a negative restriction on an expression. 
	 
</UL>
<HR>
<P><A NAME="AB_tail"></A><B>Example #16 (Exhaustive deletion 1 ):</B></P>
<P><A HREF="test_web_eng/test_AB_tail.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> A correct version of the exhaustive deletion algorithm. 
	 
</UL>
<HR>
<P><A NAME="ABmoved"></A><B>Example #17 (Exhaustive deletion 2 ):</B></P>
<P><A HREF="test_web_eng/test_ABmoved.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> Another correct version of the exhaustive deletion. 
	 
</UL>
<HR>
<P><A NAME="CheckB"></A><B>Example #18 (CheckForB)</B></P>
<P><A HREF="test_web_eng/test_ba1.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> Given a function generating a string in the language
	'A'*, the task is to check the last letter of the string is never 'B'. 
	 
</UL>
<HR>
<P><A NAME="CheckB2"></A><B>Example #19 (CheckForB2)</B></P>
<P><A HREF="test_web_eng/test_ba2.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> Given a function generating a string in the language
	'A'*, the task is to check the last letter of the string never	contains 'B'. 
	 
</UL>
<HR>
<P><A NAME="Look"></A><B>Example #20 (Word Equations)</B></P>
<P><A HREF="test_web_eng/test_look.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> Existence of the multiple t-variables in the pattern
	may lead to an equation generation. 
	 
</UL>
<HR>
<P><A NAME="Order"></A><B>Example #21 (InfCall)</B></P>
<P><A HREF="test_web_eng/test_order.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The normal computation order on the associative data
	may lead to non-trivial function order in a stack. 
	 
</UL>
<HR>
<P><A NAME="PalAB"></A><B>Example #22 (PalAB)</B></P>
<P><A HREF="test_web_eng/test_palplusAB.ref">The input and the residual program</A>
</P>
<UL>
	<LI> If we append the prefix 'AB' to the
	string and then append its inversion, we can never get a palindrome.
		 
</UL>
<HR>
<P><A NAME="BAincorrect"></A><B>Example #23 (Not only 'A'-s):</B></P>
<P><A HREF="test_web_eng/test_ba_incorrect.ref">The input and the residual program</A>
</P>
<UL>
	<LI> A simple test on removing refuted hypotheses after a
	generalization. First, the hypothesis of belonging to the language A*
	is generated. When the next generalization attempt is done, it is refuted. 
	 
</UL>
<HR>
<P><A NAME="Singapore"></A><B>Example #24 (Thinh et al test):</B></P>
<P><A HREF="test_web_eng/test_Singapore.ref">The input and the residual program</A>
</P>
<UL>
	<LI> The test from the paper: M.T Trinh, D.H Chu, J.
	Jaffar, Progressive reasoning over recursively-defined strings /
	International Conference on Computer Aided Verification, 2016,
	218-240.<!-- Progressive Reasoning over Recursively-Defined Strings / M.T.Trinh et al -->
		 
</UL>
<HR>
<P><A NAME="Sweden"></A><B>Example #25 (Abdulla et al test):</B></P>
<P><A HREF="test_web_eng/test_Sweden.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The test from the paper: Parosh Aziz Abdulla,
	Mohamed Faouzi Atig, Yu-Fang Chen, Bui Phi Diep, Lukas Holik, Ahmed
	Rezine, Philipp Rummer. Flatten and conquer: a framework for
	efficient analysis of string constraints, Programming Language
	Design and Implementation (PLDI), 2017, Barcelona, Spain, ACM, pages
	602-617. <!-- Flatten and Conquer. A Framework for Efficient Analysis of String Constraints / P.A.Abdulla et al. -->
		 
</UL>
<HR>
<P><A NAME="OpenVar"></A><B>Example #26 (Open variables test):</B></P>
<P><A HREF="test_web_eng/test_openvars.ref">The input and the residual program</A>
</P>
<UL>
	<LI> A test on processing open variables in patterns. 
	 
</UL>
<HR>
<P><A NAME="NonQuad"></A><B>Example #27 (Non-quadratic equations
test):</B></P>
<P><A HREF="test_web_eng/test_nonquadratic.ref">The input and the residual program</A>
</P>
<UL>
	<LI> Given a non-quadratic equation, the supercompiler	manages to solve it combining elementary actions. 
	 
</UL>
<HR>
<P><A NAME="ScriptScript"></A><B>Example #28 (Incorrect
sanitization):</B></P>
<P><A HREF="test_web_eng/test_Script1.ref">The input and the residual program</A>
</P>
<UL>
	<LI> A simple sanitization algorithm is shown to be incorrect. 
	 
</UL>
<HR>
<P><A NAME="ScriptIp"></A><B>Example #29 (Correct sanitization &ndash; ip):</B></P>
<P><A HREF="test_web_eng/test_Script.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The test is taken from the paper: M.T Trinh, D.H
	Chu, J. Jaffar, Progressive reasoning over recursively-defined
	strings / International Conference on Computer Aided Verification,
	2016, 218-240. 

A sanitization algorithm is shown to be correct in respect with the given conditions. 
	 
</UL>
<HR>
<P><A NAME="ScriptBrackets"></A><B>Example #30 (Correct sanitization &ndash; brackets):</B></P>
<P><A HREF="test_web_eng/test_Script2.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The test is taken from the paper: M.T Trinh, D.H
	Chu, J. Jaffar, Progressive reasoning over recursively-defined
	strings / International Conference on Computer Aided Verification,
	2016, 218-240. 

A sanitization algorithm is also shown to be correct in respect with the given conditions. 
	 
</UL>
<HR>
<P><A NAME="ScriptIpNB"></A><B>Example #31 (Correct sanitization &ndash; ip and no blanks):</B></P>
<P><A HREF="test_web_eng/test_Script3.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> A modified version of the test #29. 
	 
</UL>
<HR>
<P><A NAME="ScriptSilly"></A><B>Example #32 (Correct but silly sanitization):</B></P>
<P><A HREF="test_web_eng/test_script0.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> A simple sanitization algorithm is shown to be correct. 
	 
</UL>
<HR>
<P><A NAME="scriptComplex"></A><B>Example #33 (Guarnieri et al test):</B></P>
<P><A HREF="test_web_eng/test_scriptComplex.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The test is taken from the paper

 Guarnieri, M. Pistoia, O. Tripp, Ju. Dolby, S. Teilhet, R. Berg. Saving the World Wide Webfrom Vulnerable JavaScript // 
In: Proceedings of the 2011 International Symposium on Software Testing and Analysis (ISSTA '11), pp: 177-187, 2011

A sanitization of the innertext method. 
	 
</UL>
<HR>
<P><A NAME="finiteletter"></A><B>Example #34 (Square subword):</B></P>
<P><A HREF="test_web_eng/test_finiteletter.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> Proving that every word in the alphabet {'A', 'B'} has a square subword. 
	 
</UL>
<HR>
<P><A NAME="KMPtest"></A><B>Example #35 (Naive matching to KMP):</B></P>
<P><A HREF="test_web_eng/test_KMPtest.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> A version of the classical supercompiler test for the associative data type. 
	 
</UL>
<HR>
<P><A NAME="sumcomm"></A><B>Example #36 (Commutativity of the addition):</B></P>
<P><A HREF="test_web_eng/test_sumcomm.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The commutativity of the associative addition (on strings representing unary numbers).
	This example is motivated by the example of the manual supercompilation proving commutativity of the addition operation
	given on p.213 (Example 6) in: 
	<a href="http://pat.keldysh.ru/~roman/doc/Turchin/1980-Turchin--The_Language_REFAL--The_Theory_of_Compilation_and_Metasystem_Analysis.pdf">
         F. Turchin. The Language REFAL, the Theory of Compilation, and Metasystem Analysis.</a> Courant Institute Report #20, New York, 1980, 245 p. 
	 
</UL>
<HR>
<P><A NAME="RefalMachine"></A><B>Example #37 (Interpretation of Zip function):</B></P>
<P><A HREF="test_web_eng/RefalMachine.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The specialization task is as follows, where <code>&#37;Zip-Source</code> stands for the <code>Zip</code> source code.  

<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;...............................................&nbsp; &gt;</tt></code></td> 
  </tr>
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Interpreter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#e.data&nbsp;&nbsp;&nbsp;.................&nbsp;
          &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Zip &nbsp;&nbsp;!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&#37;Zip-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>
	
	<LI> The input program is an interpreter of a subset of Refal language. 
	The residual program is a version of the <code>Zip</code> function definition.
	 
</UL>
<HR>
<P><A NAME="weqs_int_base_new"></A><B>Example #38 (Word equations interpreter &ndash; xAy = yBx):</B></P>
<P><A HREF="test_web_eng/weqs_int_base_new.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The specialization task is as follows, where <code>&#37;Eq-Source</code> stands for the <code>Eq</code> source code.  

<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;.........................................&nbsp; &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Eq #e.Path (x A y)(y B x)&gt;&nbsp;&#37;Eq-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>

<!--
<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;.........................................&nbsp; &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Eq #e.Path (LHS)(RHS)&gt;&nbsp;&#37;Eq-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>
-->
	
	<LI>The input program is an interpreter <code>Eq</code> of the paths solving word equations. 
	The residual program represents a graph of the solutions of the given word equation <code>x++A++y = y++B++x</code>. The program does not
	contain outputs with the value <code>True</code>; thus we have proved the fact that the equation <code>x++A++y = y++B++x</code> has no solutions. 
	 
</UL>
<HR>
<P><A NAME="weqs_int_base_1"></A><B>Example #39 (Word equations interpreter &ndash; ABxy = xyBA):</B></P>
<P><A HREF="test_web_eng/weqs_int_base_1.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The specialization task is as follows, where <code>&#37;Eq-Source</code> stands for the <code>Eq</code> source code.  

<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;.............................................&nbsp;
          &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Eq #e.Path (A B x y)(x y B A)&gt;&nbsp;&#37;Eq-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>

<!--	
<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;.........................................&nbsp;
          &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Eq #e.Path (LHS)(RHS)&gt;&nbsp;&#37;Eq-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>
-->

	<LI> The input program is an interpreter of the paths solving word equations. 
	The residual program represents a graph of the solutions of the given word equation <code>A++B++x++y = x++y++B++A</code>.
	 
</UL>
<HR>
<P><A NAME="weqs_int_base_2"></A><B>Example #40 (Word equations interpreter &ndash; xAy = zzz):</B></P>
<P><A HREF="test_web_eng/weqs_int_base_2.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The specialization task is as follows, where <code>&#37;Eq-Source</code> stands for the <code>Eq</code> source code.  

<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;.........................................&nbsp;
          &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Eq #e.Path (x A y)(z z z)&gt;&nbsp;&#37;Eq-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>

<!--
<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;.........................................&nbsp;
          &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Eq #e.Path (LHS)(RHS)&gt;&nbsp;&#37;Eq-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>
-->
	
	<LI> The input program is an interpreter of the paths solving word equations. 
	The residual program represents a graph of the solutions of the given word equation <code>x++A++y = z++z++z</code>. The graph is finite.
	 
</UL>
<HR>
<P><A NAME="weqs_int_base_3"></A><B>Example #41 (Word equations interpreter &ndash; zAByx = yzxBA):</B></P>
<P><A HREF="test_web_eng/weqs_int_base_3.ref">The input and the residual program</A> 
</P>
<UL>
	<LI> The specialization task is as follows, where <code>&#37;Eq-Source</code> stands for the <code>Eq</code> source code.  

<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;.................................................&nbsp;
          &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Eq #e.Path (z A B y x)(y z x B A)&gt;&nbsp;&#37;Eq-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>

<!--
<table border="0" cellpadding="0" cellspacing="0" width="40%" bgcolor="white" >   
  <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&lt;Scp&nbsp;&nbsp;&nbsp;.........................................&nbsp;
          &gt;</tt></code></td> 
  </tr>
   <tr> 
        <td width="89%" align="left"><code><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &lt;Eq #e.Path (LHS)(RHS)&gt;&nbsp;&#37;Eq-Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</tt></code></td>
   </tr>
</table>
-->	
	<LI> The input program is an interpreter of the paths solving word equations. 
	The residual program represents a graph of the solutions of the given word equation <code>z++A++B++y++x = y++z++x++B++A</code>.
	 
</UL>
</BODY>
</HTML>
