/*
 Слегка измененный пример test_strangeprefix.ref.
 Теперь после конкатенации, реализуемой с конца, к началу слова приписывается слово 'АB'.
 Префиксом такого слова его последующий отрезок будет, только если он имеет вид ['AB']^n ['A'| EMPTY].

 Цикл в Prefix_0 просто проверяет, состоит ли второй аргумент Go из s-символов.
 Prefix_123_1 и Prefix_123_2 проверяют первый аргумент Go на указанное выше условие.
 Функции Prefix_123_2 второй и третий аргументы не нужны!
*/

/***********************************************/
/*          исходная программа                 */
/***********************************************/

*$MST_FROM_ENTRY;

$ENTRY Go {
 (e.x) e.y = <Prefix (e.x) <Concat (e.x) e.y>>;
}

Prefix {
 () e.2 = 'T';
 (s.x e.1) s.x e.2 = <Prefix (e.1) e.2>;
 ('A' e.1) 'B' e.2 = 'F';
 ('B' e.1) 'A' e.2 = 'F';
 (t.x e.1) = 'F';
}

Concat {
 (e.1) = 'AB'e.1;
 (e.1) e.2 s.x = <Concat (e.1) e.2> s.x;
}

/***********************************************/
/*          остаточная программа               */
/***********************************************/
/*

$ENTRY Go {
 (e.1) e.2 =  <InputFormat_0 (e.1) (e.2)>;
}


InputFormat_0 {
 () (e.1) =  'T';
 ('A' e.1) () =  <Prefix_123_1 e.1>;
 ('B' e.1) () =  'F';
 (s.1 e.1) (e.2 s.2) =  <Prefix_0 (s.1) (e.1) (e.2) (s.2) ()>;
}


Prefix_123_1 {
 =  'T';
 'B' =  'T';
 'BA' e.1 =  <Prefix_123_1 e.1>;
 'BB' e.1 =  'F';
 'A' e.1 =  'F';
}


Prefix_123_2 {
 () (s.1) (e.1) =  'T';
 ('B') (s.1) (e.1) =  'T';
 ('BA' e.1) (s.1) (e.2) =  <Prefix_123_2 (e.1) (s.1) (e.2)>;
 ('BB' e.1) (s.1) (e.2) =  'F';
 ('A' e.1) (s.1) (e.2) =  'F';
}


Prefix_0 {
 ('A') (e.1) () (s.1) (e.2) =  <Prefix_123_2 (e.1) (s.1) (e.2)>;
 ('B') (e.1) () (s.1) (e.2) =  'F';
 (s.1) (e.1) (e.2 s.2) (s.3) (e.3) =  <Prefix_0 (s.1) (e.1) (e.2) (s.2) (s.3 e.3)>;
}

*/

