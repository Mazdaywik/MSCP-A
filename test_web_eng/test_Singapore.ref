/*
 Тест взят из статьи 2016 года на CAV:
 M.T Trinh, D.H Chu, J. Jaffar, Progressive reasoning over recursively-defined strings /
 International Conference on Computer Aided Verification, 218-240

 Тест, в котором проверяется наличие буквы 'D' в слове 'A'^n 'B'^n 'C'^n.
 Здесь многократно отрабатывает тот же эффект, что и в test_ba2.ref.
 Поскольку группы одинаковых букв, выкидываемые функциями Gram, отделены друг от друга
 этими вызовами, суперкомпилятору удаётся сохранить информацию об их однородности.
*/

/***********************************************/
/*          исходная программа                 */
/***********************************************/

$ENTRY Go {
 e.1 =  <G0 <GramA e.1> <GramB e.1> <GramC e.1>>;
}


GramA {
	'I' e.x = 'A' <GramA e.x>;
	= ;
}
GramB {
	'I' e.x = 'B' <GramB e.x>;
	= ;
}
GramC {
	'I' e.x = 'C' <GramC e.x>;
	= ;
}

G0 {
         = 'T';
	e.1 'D'  = 'F';
        e.1 t.x = <G0 e.1>;
}

/***********************************************/
/*          остаточная программа               */
/***********************************************/

/*
$ENTRY Go {
 e.1 =  <InputFormat_0 e.1>;
}


InputFormat_0 {
 'I' e.1 =  <G0_1 (e.1) () (e.1)>;
 =  'T';
}


G0_1 {
 (e.1) (e.2) ('I' e.3) =  <G0_1 (e.1) (e.2 'C') (e.3)>;
 (e.1) (e.2) () =  <G0_3_1 (e.1) (e.2)>;
}


G0_2 {
 (e.1) (e.2) ('I' e.3) =  <G0_2 (e.1) (e.2 'B') (e.3)>;
 (e.1) (e.2) () =  <G0_3_2 (e.1) (e.2)>;
}


G0_3_1 {
 (e.1) (e.2 'C') =  <G0_3_1 (e.1) (e.2)>;
 (e.1) () =  <G0_2 (e.1) () (e.1)>;
}


G0_3_2 {
 (e.1) (e.2 'B') =  <G0_3_2 (e.1) (e.2)>;
 (e.1) () =  <G0_3 () (e.1)>;
}


G0_3 {
 (e.1) ('I' e.2) =  <G0_3 (e.1 'A') (e.2)>;
 (e.1) () =  <G0_3_0 e.1>;
}


G0_3_0 {
 e.1 'A' =  <G0_3_0 e.1>;
 =  'T';
}
*/
