
/*
   Модуль функций прогонки.
   
   Основные функции модуля:
   
   SolveEquations --- функция запуска решения уравнений в словах в конфигурации прогонки.
   ([PRTC]) => ([PRTC])
   
   PostProcessPRTC --- обработка конфигурации после прогонки (и решения уравнений).
   (((e.equations)(e.restrictions)(e.assignments))^*)(e.MultisetOfCalls)
   ([NonClashPRTC])^*
   =>
   (((e.equations)(e.restrictions)(e.assignments))^*)(s.Log)((call [functioncall])|\Lambda
   
   GenerateNextLevel --- построение очередного узла в дереве вычислений программы по результатам прогонки.
   Формат:
   [ParentNodeName](t.NumberOfGeneratedChildren) 
   ((e.ParentRestrictions)(e.ParentEquations)(e.ParentLets)(e.ParentFullConfiguration)[ParentStack])
   ([PatternFunctionName] (Try e.ArgumentOfPatternFunction)(SubstTo e.CurrentPatternOfRightSide)(e.OtherPatterns))
   (((e.equations)(e.restrictions)(e.assignments))^*)
   (s.Log)
   ((call [functioncall])|\Lambda)
   =>
   (Node Undriven|Ready [NewNodeName] ((Push|Always|[restriction]^+) (Equations) ()([FullConfig])[Stack]))^*
   
   AssignTimeStamps --- назначение временных меток вызовам в выражении.
   [Expr] => [Expr]
   
   ParametrizeAllEq --- замена рефал-данных в уравнениях на абстрактные переменные.
   
   Drive --- функция прогонки.
   
   ClashLeft --- функция сопоставления с образцом слева (она же запускает функцию сопоставления справа, не видимую вне модуля).
   ((e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log))=>((e.equations)(e.restrictions)(e.assignments)((Delayed e.Clashes))(s.Log))^*
   
   Структуры данных в прогонке.
   
   [ClassicEquality] ::= (AreEqual (s.IfIsChanged)([EqualityExpr])([EqualityExpr]))
   [SimpleCallEqualities] ::= (AreEqual (s.IfIsChanged)((call [DataExpr]))([EqualityExpr])) [SimpleCallEqualities]| 
   
   [Stack]::= ([StackLevel]^+)
   [StackLevel]::= ((assign (var l t.varname)([StackExpression])))
   [StackExpression] :: = | ('*' [StackExpression]) [StackExpression] | s.X [StackExpression] 
			| (par s.partype e.parname) [StackExpression] | (var l t.stackvarname) [StackExpression]
   
   [NonClashPRTC]::= Zero |
	([ClassicEquality]^* (Desired [SimpleCallEqualities])
	((assign (par t.type t.name) ([DataExpr])))^*)
	((assign (var t.type t.name) ([DataExpr])))^*)
	((Delayed))
	(s.Log)
   
   [PRTC]::= Zero |
	([ClassicEquality]^* (Desired [SimpleCallEqualities])
	((assign (par t.type t.name) ([DataExpr])))^*)
	((assign (var t.type t.name) ([DataExpr])))^*)
	([Clash]^* (Delayed [Clash]^*))
	(s.Log)
   [Clash]::= (([DataExpr]) to ([PatternExpr]))
   [DataExpr]::= |('*' [DataExpr])[DataExpr]|[Symbol][DataExpr]|(par t.type t.name)[DataExpr]|(call t.fname (args (arg [DataExpr])))
   [PatternExpr]::= |('*' [PatternExpr])[PatternExpr]|[Symbol][PatternExpr]|(var t.type t.name)[PatternExpr]
   [EqualityExpr]::= |('*' [EqualityExpr])[EqualityExpr]|[Symbol][EqualityExpr]|
	(par t.type t.name)[EqualityExpr]|(weval t.type t.name)[EqualityExpr]|(var t.type t.name)[EqualityExpr]|
	(call t.fname (args (arg [DataExpr]))) --- это не ошибка, внутри вызова может быть только [DataExpr]
*/


$EXTERN prefal;
/* из модуля basics.ref */
$EXTERN MSCPError;
/* из модуля basics.ref */
$EXTERN MaxElementPowerMS, RandomMaxElementMS, ExtractElNameMS, MaxElementMS, ReplaceMSEl,IfASubMultiSet,Substitute, IterateSubstitute, GetParList;
/* из модуля basics.ref */
$EXTERN IfIncluded, CompareMultiSets, SubtractSetFromSet, FindMSIntersection, SubtractMS,SubtractEl,InsertInMultiSet,MergeSets;
/* из модуля basics.ref */
$EXTERN LogAnd, LogAndMerge, LogOrMerge, LogOr, FindTerm, TermContradiction, LessGenericPattern, IsTerm,IfGround, SetIntersect;
/* из модуля basics.ref */
$EXTERN FreshIndex, CurrentIndex,RenewIndices,MyInc, MyOne, MyZero, MyMax, MyAdd, MySub, MyIfNotLess, MytoBool, MyMin, MyNewLevel;
/* из модуля WordEquations.ref */
$EXTERN IfProcessible, IterateProcessQWEs, ParametrizeExpression, PlaceTwoSidesInEquality;
/* из модуля stack.ref */
$EXTERN YieldDecomposition, Lazy_Stack_Substitution,DecompAfterIndefinite;

/* из модуля accessMSCP.ref */
$EXTERN IsContradictory,NullifyPRTC,GetPRTCDelayedCl,PutPRTCDelayedCl,DeleteLastPRTCClash,PutPRTCClash,GetPRTCClash,
    PutPRTCAsg,GetPRTCAsgs,ReplacePRTCAsgs,
    PutPRTCRestr,GetPRTCRestrs,GetPRTCCallRestrs,PutPRTCCallRestr,
    PRTCOutputForm, GenerateFreshPRTC,
    ReplacePRTCCallRestrs,ReplacePRTCClashes,GetPRTCAllClashes,
    ReplacePRTCEqs,ReplacePRTCDelayedCl,
    GetPRTCAllEqs,PutPRTCNewEq, ReplacePRTCNewEqs, GetPRTCNewEqs, ReplacePRTCAllEqs, AddPRTCGenericEqs,
    SubstInNewEqs, SubstInAllEqs, FormEquationBlock,
    GetPRTCNegativeInfo,AddPRTCNegativeInfo,ReplacePRTCNegativeInfo, GetNewEqsFromEqs;
$EXTERN PutNodeNewEqsToOld, GetNodeConfFromStack, PutNodeEqs, GenerateNewNode,
    PutNodeConfig, PutNodeStack, PutNodeStatus, PutNodeRestrictions,
    GetStackTop, GetNodeStack, GetNodeConfig, GetNodeEqs, PutNodeNegEqs, GetNodeRestrictions,
    GetEBAsgs, GetEBNewEqs, GetEBProgramDataAsgs, IntegrateEBEqsInPRTC, CheckVarDependencies;

/* из модуля WordEquations.ref */
$EXTERN IterateSWEforEB, IterateWEforPRTCs;

/*
    Проверка, может ли выражение оказаться пустым.
   Возвращает вызов, от которого зависит ответ на вопрос, является ли оно пустым.
   Вход:
   ((call [args])|\Lambda)[stack_expression]
   Выход:
   ((call [args])|\Lambda)(s.Log), s.Log='N'|'F'
*/
IfMayBeEmpty {
	(e.Indefinite) = (e.Indefinite)('N');
	()(call e.call) e.z = <IfMayBeEmpty ((call e.call)) e.z>;
	(e.Indefinite)(call e.call) e.z = <IfMayBeEmpty (e.Indefinite)e.z>;
	(e.Indefinite)(var l e.var) e.z = <IfMayBeEmpty (e.Indefinite)e.z>;
	(e.Indefinite)(t.sort e e.parname) e.z = <IfMayBeEmpty (e.Indefinite)e.z>;
	(e.Indefinite)e.Z = (e.Indefinite)('F');
}

/*
    Главная функция для решения уравнений в словах.
   На входе:
   ([PRTC]) (может быть, что PRTC = Zero)
   На выходе:
*   ([PRTC]) 
*/


$ENTRY SolveEquations {
    t.PRTC, <IsContradictory t.PRTC> : 'T' = ;
/*
    	t.PRTC,
        <GetPRTCNewEqs t.PRTC> : e.equations
	 = <PostProcessEquations 
             <SubstituteWevals <IterateSWEforEB <IterateWEforPRTCs 
                <FormEquationBlock 
                     <ParametrizeAllEq e.equations> t.PRTC
                >
        >>>>; 
*/

    t.PRTC
    , <GetPRTCNewEqs t.PRTC> : e.equations
    , <GetPRTCCallRestrs t.PRTC> : e.CR
    , <GetPRTCRestrs t.PRTC> : e.ActiveRestrs
    , <FormEquationBlock <ParametrizeAllEq e.ActiveRestrs e.equations (Desired e.CR)> t.PRTC> :
        (Inactive e.InactiveEqs)t.EB
        =  
        <Br 'SolveEqMode=0'> 
        <SubstituteWevals 
            (e.InactiveEqs) <IterateWEforPRTCs t.EB> t.PRTC
        >;
}

/*
    Заключительная обработка конфигураций прогонки после решения уравнений.
   [PRTC]^* => [PRTC]^*
*/
PostProcessEquations {
    = ;
    t.PRTC e.Confs, <IsContradictory t.PRTC>: 'T' = <PostProcessEquations e.Confs>;
/*
    	((e.equations (Desired e.calls))(e.restrictions)(e.assignments)((Delayed e.Clashes))(s.Log))e.Confs = 
		((<DeleteMultipleEqs () e.equations> (Desired <DeleteMultipleEqs () e.calls>))(e.restrictions)(e.assignments)((Delayed e.Clashes))(s.Log))
		<PostProcessEquations e.Confs>; 
*/
    t.PRTC e.Confs  
        = 
        t.PRTC
        <PostProcessEquations e.Confs>;
}


/*
   Удаление повторных уравнений из блока уравнений.
   ([ClassicEquality]^*)[ClassicEquality]^* 
   =>[ClassicEquality]^* 
*/
DeleteMultipleEqs {
        e.PosEq (Desired e.CallEq) = <DeleteMultipleEqs e.PosEq>(Desired <DeleteMultipleEqs e.CallEq>);
        e.PrEq (AreEqual (s.Log)t.LHS t.LHS) e.PrEq2 = <DeleteMultipleEqs e.PrEq e.PrEq2>;
	e.PrEq (AreEqual (s.Log)t.LHS t.RHS) e.PrEq2 (AreEqual (s.Log2)t.RHS t.LHS) e.PrEq3 = <DeleteMultipleEqs e.PrEq e.PrEq2 e.PrEq3>;
	e.PrEq (AreEqual (s.Log)t.LHS t.RHS) e.PrEq2 (AreEqual (s.Log2)t.LHS t.RHS) e.PrEq3 = <DeleteMultipleEqs e.PrEq e.PrEq2 e.PrEq3>;
        e.PrEq = e.PrEq;
}

/*
    Проверка, входит ли данное уравнение в заданный блок уравнений.
   ([CheckedClassicEquality]^*)([NonCheckedClassicEquality]^*)[ClassicEquality] =>
   [CheckedClassicEquality]^*
*/
CheckNewEq4Multiplicity {
    e.NPEq (AreEqual (s.Log1)(t.LHS)(e.RHS)) e.NPEq2 (AreEqual (s.Log2)(t.LHS) (e.RHS)) 
		= () e.NPEq (AreEqual (s.Log1)(t.LHS)(e.RHS)) e.NPEq2;
    e.NPEq (AreEqual (s.Log1)(t.LHS)(e.RHS)) e.NPEq2 (AreEqual (s.Log2)(t.LHS) (e.RHS2)) 
		= (AreEqual ('F')(e.RHS)(e.RHS2)) e.NPEq (AreEqual (s.Log1)(t.LHS)(e.RHS)) e.NPEq2;
    e.NPEq (AreEqual (s.Log)(t.LHS)(e.RHS)) 
		= () e.NPEq (AreEqual (s.Log)(t.LHS)(e.RHS));
}

/**************************************************************************************
   
                     ОБЩИЕ ФУНКЦИИ ПРОГОНКИ
    
**************************************************************************************/

/*
   Выбор функции для выталкивания (если это необходимо) по результатам попытки сопоставления. 
   Вход:
   (((e.equations)(e.restrictions)(e.assignments))^*)(e.MultisetOfCalls)
   ([NonClashPRTC])^*
   Выход:
   (((e.equations)(e.restrictions)(e.assignments))^*)(s.Log)((call [functioncall])|\Lambda)
   s.Log = 'F' => невозможность сопоставления во всех ветвях прогонки;
   s.Log = 'N' => имеется вызов функции, без уточнения которого нельзя установить, успешно ли сопоставление;
   s.Log = 'T' => сопоставление возможно (независимо от значений вызовов функций).
*/
$ENTRY PostProcessPRTC {
/* 1. Все возможные конфигурации прогонки содержат противоречия => сопоставление невозможно. */
    ()() = ()('F')();
/*
   2. Ни в одной конфигурации прогонки нет неопределенностей, и есть хотя бы одна конфигурация, не содержащая противоречий
	=> безотносительное сопоставление возможно. 
*/
    (e.ProcessedConfs)() = (e.ProcessedConfs)('T')();
/* 3. Мультимножество вызовов, порождающих противоречия, непусто => нужно найти в нем элемент с наибольшим весом. */
    (((e.Eqs)(e.Restrs)(e.Asgs)) e.ProcessedConfs)(e.MSCalls)
            = <Putout 1 'Multiset of calls to be resolved:'>
            <Putout 1 e.MSCalls>
            ()('N')((<FindTightNarrowing (e.Restrs)e.ProcessedConfs>)
            <ExtractElNameMS <MaxElementMS (e.MSCalls)>>);

/* 4. Блок Desired текущей конфигурации пуст => она помещается в конфигурации, не содержащие неопределенностей. */
    (e.ProcessedConfs)(e.MSCalls) t.PRTC e.Confs
    , <GetPRTCCallRestrs t.PRTC> : 
    , <PRTCOutputForm t.PRTC> : t.NodePRTC
        = <PostProcessPRTC (e.ProcessedConfs t.NodePRTC)(e.MSCalls)e.Confs>; 

/* 5. Противоречивая конфигурация просто удаляется. */
    (e.ProcessedConfs)(e.MSCalls) t.PRTC e.Confs
    , <IsContradictory t.PRTC> : 'T' 
        = <PostProcessPRTC (e.ProcessedConfs)(e.MSCalls) e.Confs>; 

/* 6. В случае непустого блока Desired текущей конфигурации все вызовы, на которые в нем имеются сужения, добавляются в мультимножество неопределенностей. */
    (e.ProcessedConfs)(e.MSCalls) t.PRTC e.Confs
    , <GetPRTCCallRestrs t.PRTC> : e.calls
        = <PostProcessPRTC (e.ProcessedConfs <PRTCOutputForm t.PRTC>)<AddCallsToMS (e.calls)(e.MSCalls)> e.Confs>; 
}

FindTightNarrowing {
    (e.Narrowings) = e.Narrowings;
    ()e.Other = ;
    (e.Narrowings)((e.Eqs)(e.Restrs)(e.Asgs)) e.Other
        = <FindTightNarrowing <SetIntersect (e.Narrowings)(e.Restrs)>e.Other>;
}

/*
    Добавление вызова из блока Desired во взвешенный список вызовов, неопределенных в данном сопоставлении.
   Вызов, уточняемый явно, имеет больший вес, чем вызов, вовлечённый только в уравнения 
   (уточняемый только неявно).
   Вход:
   ((call [functioncall])^*)((t.Weight (call [functioncall]))^*)
   Выход:
   ((t.Weight (call [functioncall]))^*)
*/
AddCallsToMS {
    ()(e.MSCalls) = (e.MSCalls);
    ((AreEqual (s.Log)(t.call)((weval e e.Z))) e.calls)(e.MSCalls)
        = <AddCallsToMS (e.calls)(<InsertInMultiSet (e.MSCalls)(<MyOne> t.call)>)>;
    ((AreEqual (s.Log)(t.call)(e.Val)) e.calls)(e.MSCalls)
        = <AddCallsToMS (e.calls)(<InsertInMultiSet (e.MSCalls)(<MyInc <MyOne>> t.call)>)>;
}

/*
    Прогонка одного правила определения функции закончена.
   Обрабатываем ее результат.
   Вход:
   [ParentNodeName](t.NumberOfGeneratedChildren) 
   ((e.ParentRestrictions)(e.ParentEquations)(e.ParentLets)(e.ParentFullConfiguration)[ParentStack])
   ([PatternFunctionName] (Try e.ArgumentOfPatternFunction)(SubstTo e.CurrentPatternOfRightSide)(e.OtherPatterns))
   (((e.equations)(e.restrictions)(e.assignments))^*)
   (s.Log)
   ((call [functioncall])|\Lambda)
   Выход:
   (Node Undriven|Ready [NewNodeName] ((Push|Always|[restriction]^+) (Equations) (e.ParentLets)([FullConfig])[Stack]))^*
*/
$ENTRY GenerateNextLevel {
/* 1. Ни одной дочки порождено не было, предложений в выражении больше не осталось. */
    (s.CurrNum)()(e.Negative) 
    t.NodeName (0) t.Node (t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)())()('F')() t.Status
        = () t.Status;

/* 2. На последнем сопоставлении получено противоречие, предложений в выражении больше не осталось. */
    (s.CurrNum)(e.Set)(e.Negative)t.NodeName t.NodeChildren t.Node (e.PatternConfig())()('F')() t.Status
        = (e.Set) t.Status;

/* 3. Все ветви узла порождены, предложений в выражении больше не осталось. */
    (s.CurrNum)(e.Set)(e.Negative)t.NodeName t.NodeChildren t.Node (e.PatternConfig())()('T')() t.Status
        = (e.Set s.CurrNum) t.Status;

/* 4. Все ветви узла порождены, но остались еще предложения в определении функции. */
    (s.CurrNum)(e.Set)(s.Mode e.Negative)t.NodeName t.NodeChildren t.Node
        (t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(((e.LHSDef)e.RHSDef)e.OtherDefinitions))()(s.Log)()t.Status
    , <GetNodeEqs <PutNodeNewEqsToOld t.Node>> : e.ParentEquations
    , <GenerateFreshPRTC (e.LHSDef)(e.CurrConfig)> : t.NewPRTC
    , <AddPRTCNegativeInfo 
        <ReplacePRTCAllEqs t.NewPRTC e.ParentEquations> 
            e.Negative
    >: t.NewGeneratedPRTC                
        = <GenerateNextLevel 
            (<Add s.CurrNum 1>)
            (<InsertIfMod s.Mode s.CurrNum e.Set>)
            (Unmod e.Negative)t.NodeName t.NodeChildren 
            t.Node
            (t.fname (Try e.CurrConfig)(SubsTo e.RHSDef)(e.OtherDefinitions))
            <PostProcessPRTC 
                ()()<Putout 1 'New Clash:'>
                    <Drive () <ClashLeft 0 <Put 1 t.NewGeneratedPRTC>>><Putout 1>
            >
            t.Status
        >;
/*
    5. Выяснилось, что необходимо выталкивать вызов функции --- порождаем единственную
   дочку узла дерева, содержащую конфигурацию, где этот вызов активен.
   Данная конфигурация затем заменит собой конфигурацию родительского узла. 
   ВООБЩЕ ГОВОРЯ, этот вызов может находиться через несколько уровней декомпозиции.
   Пример: 
   <F (<G e.x <H e.x> e.x>)(<G e.x e.x e.x>)> 
   F {t.1 t.1 = 'T';}
   Нужно толкать не G, а H!
   Поэтому это предложение должно быть переписано.
   Декомпозиция должна происходить по подстановке.
   Может быть 1 - тогда она совпадает с ленивой.
   Может быть inf - тогда она совпадает с аппликативной.
   Может быть (e.call) - значит, разбираем до указанного вызова.
*/
    (s.CurrNum)(e.Set)(s.Mode e.Negative) t.NodeName (t.NodeChild) t.Node
        (t.fname (Try e.CurrConfig)(SubsTo e.RHSDef)(e.OtherDefinitions))()('N')((e.Narrowings)t.call)t.Status
    , <GenerateNewName t.NodeName (t.NodeChild)> : t.NewNodeName
    , <GetNodeEqs t.Node> : e.Eqs
    , <GetNodeConfig t.Node> : e.Config
    , <GetNodeStack t.Node> : e.Stack
    , e.Stack : ((assign (var l e.vardata)(e.CurrProcessedCall))e.ThisLevel) e.OtherLevels
    , e.Narrowings :
        {/* EMPTY */
            = <PutNodeRestrictions 
                <PutNodeStatus 
                    <PutNodeStack
                        <PutNodeConfig 
                            <PutNodeEqs 
                                <GenerateNewNode t.NewNodeName> 
                                e.Eqs
                            >
                            e.Config
                        >
                        <DecompAfterIndefinite t.call (e.Stack)(var l e.vardata t.fname) e.CurrConfig>
                    >
                Ready
                > 
                Push
            > (Unchanged) Driven;
        e.Restrs
            = <PutNodeRestrictions 
                <PutNodeStatus 
                    <PutNodeStack
                        <PutNodeConfig 
                            <PutNodeNegEqs 
                                <PutNodeEqs 
                                    <GenerateNewNode t.NewNodeName> 
                                    <SubstInAllEqs (e.Restrs)e.Eqs>
                                > 
                                e.Negative
                            >
                        <IterateSubstitute (e.Restrs)e.Config>
                        >
                        <DecompAfterIndefinite 
                            <IterateSubstitute (e.Restrs)t.call> 
                            (<IterateSubstitute (e.Restrs)e.Stack>)(var l e.vardata t.fname) <IterateSubstitute (e.Restrs)e.CurrConfig>
                        >
                    >
                    Ready
                > 
                e.Restrs
            > 
            <GenerateNextLevel 
                (s.CurrNum)(<InsertAllNum <Add s.CurrNum 1> (e.OtherDefinitions) e.Set s.CurrNum>)
                (Mod (OR <ExtractNegativeInfo 
                    ((((New)(Grammar)(Negative)(Numeric)(Generic))(<AddTrivRestrs (e.CurrConfig)e.Restrs>)()))e.Negative>)e.Negative)t.NodeName (<Add t.NodeChild 1>) t.Node
                        (t.fname (Try e.CurrConfig)(SubsTo e.RHSDef)(e.OtherDefinitions))()('T')() t.Status
            >;
        };        
/*
    6. Порождается ветвь, не содержащая уравнений или рестрикций - 
   остальные предложения определения функции можно не проверять. 
*/

    (s.CurrNum)(e.Set)(s.Mode e.Negative) t.NodeName (t.NodeChild) t.Node /* ((e.OldRestrictions)(e.ConfigEquations)(e.Lets)(e.FullConfig) */
	(t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(e.OtherDefinitions))
        ((((New)(Grammar e.1)(Negative e.NewNeg)(Numeric e.2)(Generic e.4))()(e.assignments))e.OtherConfigs)('T')() t.Status
    , <GetNodeEqs t.Node> : e.Eqs
    , <GetNodeStack t.Node> : e.Stack
    , <GenerateNewNode <GenerateNewName t.NodeName (t.NodeChild)>> : t.NodeBlank
    , <PutNodeNegEqs 
        <PutNodeEqs 
            <PutNodeRestrictions t.NodeBlank Always> 
            e.Eqs
        >
        e.NewNeg
    > : t.NewNode
        =
        <GetNodeConfFromStack
            <PutNodeStack 
                <PutNodeNewEqsToOld t.NewNode>
                <StackTransform 
                    (<IterateSubstitute (e.assignments)<AssignTimeStamps e.CurrentRightSide>>)
                    (e.Stack)
                >
            >
        >
        (<InsertIfMod Mod s.CurrNum e.Set>)t.Status;
                        
/* 7. Порождается очередная ветвь. */
    (s.CurrNum)(e.Set)(e.Negative) t.NodeName (t.NumChilds) t.Node
	(t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(e.OtherDefinitions))
        (((e.equations)(e.restrictions)(e.assignments))e.OtherConfigs)('T')()t.Status
    , <GenerateNewNode <GenerateNewName t.NodeName (t.NumChilds)>> : t.BlankNode
    , <GetNodeStack t.Node> : e.Stack
    , <PutNodeEqs <PutNodeRestrictions t.BlankNode e.restrictions> e.equations> : t.NewNode
    , <GetNodeConfFromStack 
        <PutNodeStack	
            t.NewNode 
            <StackTransform 
                (<IterateSubstitute (e.assignments)<AssignTimeStamps e.CurrentRightSide>>)
                (<IterateSubstitute (e.restrictions) e.Stack>)
            >
        >> : e.NewChildConf
    , (e.Negative) :
        {(Unmod e.NegExpr)
            = e.NewChildConf
            <GenerateNextLevel (s.CurrNum)(e.Set) 
                (Mod (OR <ExtractNegativeInfo 
                    (((e.equations)
                    (<AddTrivRestrs (e.CurrConfig)e.restrictions>)
                    (e.assignments))e.OtherConfigs)e.NegExpr>)e.NegExpr)
                t.NodeName
                (<MyAdd t.NumChilds 1>) 
                t.Node                                
                (t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(e.OtherDefinitions))
                (e.OtherConfigs)('T')()t.Status
            >;
        (Mod e.NegExpr)
            = e.NewChildConf
            <GenerateNextLevel (s.CurrNum)(e.Set)
                (e.Negative)
                t.NodeName
                (<MyAdd t.NumChilds 1>) 
                t.Node                                
                (t.fname (Try e.CurrConfig)(SubsTo e.CurrentRightSide)(e.OtherDefinitions))
                (e.OtherConfigs)('T')()t.Status
            >;
        };
}

InsertAllNum {
    s.Num (/* EMPTY */) e.Set = e.Set;
    s.Num (t.Rule e.Other) e.Set
        = <InsertAllNum <Add s.Num 1> (e.Other)e.Set s.Num>;
}

InsertIfMod {
    s.Mod s.CurrNum e.1 s.CurrNum e.2 = e.1 s.CurrNum e.2;
    Unmod s.CurrNum e.Set = e.Set;
    Mod s.CurrNum e.Set = e.Set s.CurrNum;
}

/*
    Применение подстановок к стеку.
   ((assign (var l e.name)(e.Val))^*)(e.restrictions)e.Stack 
*/
SubstituteInStack {
    (e.ThisLevelProcessed)(e.restrictions)() = (e.ThisLevelProcessed);
    (e.ThisLevelProcessed)(e.restrictions)()e.OtherLevels = (e.ThisLevelProcessed)<SubstituteInStack ()(e.restrictions)e.OtherLevels>;
    (e.ThisLevelProcessed)(e.restrictions)((assign (var l e.stackvarname)(e.Val))e.ThisLevel)e.OtherLevels
        = <SubstituteInStack 
                (e.ThisLevelProcessed (assign (var l e.stackvarname)(<IterateSubstitute (e.restrictions)e.Val>)))
                (e.restrictions)(e.ThisLevel)e.OtherLevels
        >;
}

/*
    Даны два семейства уравнений. Соединить их, исключая эквивалентные.
   ([Equation]^*)[Equation]^* => [Equation]^*
*/
MergeEquations {
    (e.Eqs1 (AreEqual (s.Log1)(e.1)(e.2)) e.Eqs2) 
    e.Eqs11 (AreEqual (s.Log2)(e.1)(e.2)) e.Eqs12
        = <MergeEquations (e.Eqs1 e.Eqs2) e.Eqs11 (AreEqual (s.Log1)(e.1)(e.2)) e.Eqs12>;
    (e.Eqs1 (AreEqual (s.Log1)(e.1)(e.2)) e.Eqs2) 
    e.Eqs11 (AreEqual (s.Log2)(e.2)(e.1)) e.Eqs12
        = <MergeEquations (e.Eqs1 e.Eqs2) e.Eqs11 (AreEqual (s.Log1)(e.1)(e.2)) e.Eqs12>;
    (e.Eqs) 
    e.Eqs11 (AreEqual (s.Log) (e.1)(e.1)) e.Eqs12 
        = <MergeEquations (e.Eqs) e.Eqs11 e.Eqs12>;
    (e.Eqs1) e.Eqs2 = e.Eqs1 e.Eqs2;
}

/*
    Дано выражение, возможно, содержащее вызовы функций.
   Пронумеровать эти вызовы по времени их порождения, если они ещё не пронумерованы.
   [Expr] => [TimedCallsExp]
*/
$ENTRY AssignTimeStamps {
     = ;
    ('*' e.0) e.1 = ('*' <AssignTimeStamps e.0>) <AssignTimeStamps e.1>;
    (call t.fdata (args (arg e.Arg))) e.Other,
    t.fdata : (t.fname t.timestamp)
        = (call t.fdata (args (arg <AssignTimeStamps e.Arg>))) <AssignTimeStamps e.Other>;
    (call t.fname (args (arg e.Arg))) e.Other 
        = (call (t.fname <FreshIndex 'time_stamp'>) (args (arg <AssignTimeStamps e.Arg>))) <AssignTimeStamps e.Other>;
    t.1 e.1 = t.1 <AssignTimeStamps e.1>;
}

/*
    Преобразование стека при передаче в верхнюю его переменную нового значения.
   Вход:
   ([expression])[Stack]
   Выход:
   ([FullConfiguration])[Stack]
*/
StackTransform {
/* Верхняя переменная стека - его низ; производим декомпозицию подстановки. */
    (e.NewVal)(((assign (var l t.stackvar) (e.Val2)))) 
        = <YieldDecomposition  ((assign (var l t.stackvar) (e.NewVal)))>;

/* В противном случае подставляем верхний уровень стека в следующий за ним. */
    (e.NewVal)(((assign (var l t.stackvar) (e.Val2)) e.LowerLevel) e.OtherStack) 
        =   <StackTransformAux 
                <Lazy_Stack_Substitution 
			((assign (var l t.stackvar) (e.NewVal)) e.LowerLevel)
			(e.OtherStack)
                >
            >;
}


/*
    Продолжение преобразования стека --- уже без замены на новое значение.
   Результат --- стек, либо не содержащий вызовов, либо содержащий в нижней переменной вызов.
   Вход:
   [Stack]
   Выход:
   [Stack]
*/
StackTransformAux {
/* Получен вызов в стеке - остановка подстановок. */
    ((assign (var l t.stackvar) ((call e.call)))e.LowerLevel)e.OtherLevels
	    =((assign (var l t.stackvar) ((call e.call)))e.LowerLevel)e.OtherLevels;
/* Дошли до низа стека - декомпозиция. */
    ((assign (var l t.stackvar) (e.Val))) 
            = <YieldDecomposition  ((assign (var l t.stackvar) (e.Val)))>;
/* Иначе продолжаем подстановки. */
    ((assign (var l t.stackvar) (e.Val))e.LowerLevel)e.OtherLevels 
            =		
            <StackTransformAux 
                <Lazy_Stack_Substitution 
                ((assign (var l t.stackvar) (e.Val)) e.LowerLevel)
                (e.OtherLevels)
                >
            >;
}

/*
    Вновь порожденной дочерней ветви узла, в котором осуществляется прогонка, присваивается имя.
   Вход:
   ([NodeName])([MyNumber])
   выход:
   ([NodeName])
*/
GenerateNewName {
    (e.NodeName)(e.NodeChildren) = (e.NodeName e.NodeChildren);
}

ExtractNegativeInfo {
    () e.CurrentNegative = ;
    (((e.equations)(e.restrictions)(e.assignments))e.OtherConfigs) e.CurrentNegative
    , <GetNewEqsFromEqs e.equations> : 
        {t.Eq e.Other
            = <ExtractNegativeInfo (e.OtherConfigs) e.CurrentNegative>;
        /* EMPTY */
            = <NegativeScreening (<ExtractNegativePatterns (()()())e.restrictions>) e.CurrentNegative>
                <ExtractNegativeInfo (e.OtherConfigs) e.CurrentNegative>;
        };
}

/*
    Пока что здесь экранируются только те негативные сопоставления,
   которые полностью повторяют уже имеющиеся. В принципе должны экранироваться все,
   которые являются частными случаями уже имеющихся. 
*/
NegativeScreening {
    (e.1 t.Clash e.2) e.3 (OR t.Clash) e.4 = <NegativeScreening (e.1 e.2) e.3 (OR t.Clash) e.4>;
    () e.OldNegatives = ;
    t.NewNegative e.1 t.NewNegative e.2 = ;
    (e.NewNegative) e.OldNegatives = e.NewNegative;
}

ExtractNegativePatterns {
    (e.Assignments)(assign t.par (e.Val)) e.OtherAsgs
    , <ParametrizeExpression var(e.Assignments)()e.Val > : (e.NewAsgs)(e.Pattern)
        = ((t.par) to (e.Pattern))<ExtractNegativePatterns (e.NewAsgs)e.OtherAsgs>;
    (e.Assignments) = ;
}

$ENTRY CheckNarrowingsScreening {
    (e.Restrs)(/* EMPTY */) = /* EMPTY */;
    (e.Restrs)(t.Node2 e.Other)
    , <GetNodeRestrictions t.Node2> : e.RestrsToCompare
    , e.RestrsToCompare :
        { Push
            = t.Node2;
        e.Z
        , <ExtractNegativePatterns (()()())e.RestrsToCompare> : e.PrimitiveClashes
        , <SubstituteInClashes 1 (e.Restrs) e.PrimitiveClashes> : e.NewClashes
        , <GenerateFreshPRTC e.NewClashes> : t.NarrPRTC
        , <Drive () <ClashLeft 0 t.NarrPRTC>>
            : {/* EMPTY */ 
                = <CheckNarrowingsScreening (e.Restrs)(e.Other)>;
            e.PRTCs
            , <TrivialPRTC e.PRTCs> : 'T'
                = t.Node2;
            e.PRTCsWithRestrictions
                = <CheckNarrowingsScreening (e.Restrs)(e.Other)>;
            };
        };
}

/*
******************************************************************************************
   ФУНКЦИИ ПЕРЕВОДА УРАВНЕНИЙ КОНФИГУРАЦИИ В ЧИСТЫЕ УРАВНЕНИЯ В СЛОВАХ
   И ОБРАТНО
*******************************************************************************************
*/


/*
    Объединяем заготовки для уравнений в словах блоков desired calls и блоков equalities.
   e.Equalities(Desired e.Equalities) 
   => (e.ParameterList)(e.ParametrizedEqs)(Desired e.Equalities) 
*/

$ENTRY ParametrizeAllEq {
	e.AllEqs (Desired e.CallEqs) 
                = <ParametrizeAllEq Started (()()())()e.AllEqs e.CallEqs>;
        Started (e.ParameterList)(e.ParametrizedEqs) 
                = (e.ParameterList)(e.ParametrizedEqs);
        Started (e.ParameterList)(e.ParametrizedEqs) (assign t.par (e.Expr)) e.Rest,
        <ParametrizeExpression weval (e.ParameterList)()e.Expr> : (e.UpdParList)(e.ParamExpr)
                = <ParametrizeAllEq Started (e.UpdParList)(e.ParametrizedEqs) e.Rest>;
        Started (e.ParameterList)(e.ParametrizedEqs) (AreEqual (s.Log)(e.Expr1)(e.Expr2)) e.Rest,
        <ParametrizeExpression weval (e.ParameterList)()e.Expr1> : (e.UpdParList)(e.ParamLHS),
        <ParametrizeExpression weval (e.UpdParList)()e.Expr2> : (e.NewParList)(e.ParamRHS)
                = <ParametrizeAllEq
                    Started
                    (e.NewParList)
                    (e.ParametrizedEqs (AreEqual ('T')(e.ParamLHS)(e.ParamRHS)))
                    e.Rest
                >;
}

/* Подстановка данных вместо переменных типа weval во все конфигурации, порожденные этапом прогонки. */
SubstituteWevals {
	(e.InactiveEqs)t.PRTC = ;
/*
    Пусть блок уравнений порождает новые подстановки на weval-данные.
   Что это даёт?
   Если появилась подстановка на переменную - кладём его в assignments и всё.
   На параметр - добавляем рестрикцию (возможно, с введением новых параметров) .
   Назначение на вызов - кладём в Desired.
   На weval-переменную - значит, конфигурация обработана не полностью. См. ниже.
   
   ВСЕ уравнения в положительном блоке, наследуемые узлом-потомком, могут содержать только параметры, но не переменные, weval-переменные
   и вызовы. Если в положительном блоке New появились иные уравнения:
   1) если они содержат вызовы - значит, вызов должен толкаться.
   2) если они содержат прочие weval-переменные - эти переменные оказываются в with-блоке образца.
   А КАК БЫТЬ, если в двух частях уравнения есть weval и параметры?
   
   ПОДРАЗУМЕВАЕМ, что в самом блоке уравнений все weval-рестрикции уже подставлены.
*/
	(e.InactiveEqs) t.EB e.Other t.PRTC,
        <IsContradictory t.EB> : 'T' 
            = <SubstituteWevals (e.InactiveEqs) e.Other t.PRTC>;
        (e.InactiveEqs) t.EB e.Other t.PRTC,
	<GetEBAsgs t.EB> : e.WevalAsgs,
	<GetEBProgramDataAsgs t.EB> : e.RefAsgs,
        <IterateSubstitute (e.WevalAsgs)e.RefAsgs> : e.NewRefAsgs,
        <IntegrateEBEqsInPRTC (e.InactiveEqs) t.PRTC t.EB> : t.NewPRTC
            = 
            <SubstituteEqResultsInConf (e.NewRefAsgs) t.EB t.NewPRTC>
            <SubstituteWevals (e.InactiveEqs) e.Other t.PRTC>;
}

SubstituteEqResultsInConf {
    (e.Asgs ((assign t.call (e.Val))e.OtherCallAsgs)) t.EB t.PRTC,
        <CheckVarDependencies (e.Val) t.EB> : 
        {
            'T' 
                = <SubstituteEqResultsInConf 
                    (e.Asgs(e.OtherCallAsgs)) 
                    t.EB 
                    <PutPRTCCallRestr t.PRTC (AreEqual ('F')(t.call) (e.Val))>
                >;
            'F' 
                = <SubstituteEqResultsInConf 
                    (e.Asgs (e.OtherCallAsgs)) t.EB t.PRTC
                >;
        };
    (e.Asgs ()) t.EB t.PRTC,
    <GetPRTCCallRestrs t.PRTC> : t.1 e.1,
    <GetEBAsgs t.EB> : e.EBAsgs,
    <Substitute (e.EBAsgs) t.1 e.1> : e.NewCallRestrs
        = <ReplacePRTCCallRestrs t.PRTC e.NewCallRestrs>;
    ((e.ParAsgs)(e.VarAsgs)()) t.EB t.PRTC,
    <GetEBAsgs t.EB> : e.Asgs,
    <AssignParValues ()()<IterateSubstitute (e.Asgs)e.ParAsgs>> : (e.NewRestrictions)(e.WevalAssignments),
    <Substitute (e.WevalAssignments) e.VarAsgs> : e.NewAssignments,
    <PutPRTCAsg t.PRTC e.NewAssignments> : t.NewPRTC,
    <Substitute (e.NewRestrictions) <GetPRTCAsgs t.NewPRTC>> : e.NewAsgs
        =
        <PutPRTCRestr
        <SubstInAllEqs 
            (e.NewRestrictions)
	    <SubstInAllEqs (e.WevalAssignments)
            <ReplacePRTCAsgs t.NewPRTC e.NewAsgs>
	    >
        >
        e.NewRestrictions
        >;
}

AssignParValues {
    (e.NewRest)(e.WevAsg) = (e.NewRest)(e.WevAsg); 
    (e.NewRest)(e.WevAsg) e.1 (assign (par t.type e.name) ((weval t.type e.weval))) e.2
        = <AssignParValues 
            (e.NewRest)(e.WevAsg (assign (weval t.type e.weval) ((par t.type e.name))))
            <Substitute ((assign (weval t.type e.weval) ((par t.type e.name)))) e.1 e.2>
            >;
    (e.NewRest)(e.WevAsg) (assign t.par (e.Expr)) e.Rest,
    <GenerateNewParameterAssignments (e.WevAsg)()e.Expr> : (e.NewAsg)(e.NewExpr) 
        = <AssignParValues (e.NewRest (assign t.par (e.NewExpr)))(e.NewAsg) e.Rest>;
}


/*
   Избыточные подстановки - те, которые описывают свойства переменных, не задействованных в описании рефал-данных,
   либо в выражениях, связывающих разные переменные между собой.
   Например,
   (assign (weval e x)((call e.call))), причём (weval e x) больше нигде не встречается.
   
   Функция удаляет такие подстановки из конфигурации уравнений в словах.
   Формат
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   ((AreEqual (s.Log)((e.Multiset)(e.WevalExpression))(((e.Multiset)(e.WevalExpression)))^*)
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   (Desired e.calls)(e.Restrictions)(e.Assignments)((Delayed))(s.Log)
   =>
   ((AreEqual ((s.Log)(e.Multiset)(e.WevalExpression))((s.Log)(e.Multiset)(e.WevalExpression)))^*)
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   (Desired e.calls)(e.Restrictions)(e.Assignments)((Delayed))(s.Log)
*/
DeleteExcessiveAssignments {
    (e.ProcessedAssignments)(e.NewEquations)() t.PRTC
        = (e.NewEquations)(e.ProcessedAssignments) t.PRTC;
/*
    Три правила закомментировано 15.12.16 из-за теста StrangePal.ref c аргументом t.1 e.1.
   Здесь бестолково вычисляются бессмысленные подстановки, нужно аккуратнее. 
*/

/*
    (e.ProcessedAssignments)(e.NewEquations)((assign (weval e e.weval) t.refaldata) e.ParameterList)e.Config=
        <DelExcAssgn1 
		(assign (weval e e.weval) t.refaldata)
		<IfVarIsInEq (weval e e.weval) e.NewEquations e.ProcessedAssignments e.ParameterList>
		(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
	>;
   
    (e.ProcessedAssignments)(e.NewEquations)((assign (weval s.type e.weval) ((var s.type e.refaldata))) e.ParameterList)e.Config=
        <DelExcAssgn1 
		(assign (weval s.type e.weval) ((var s.type e.refaldata)))
		<IfVarIsInEq (weval s.type e.weval) e.NewEquations e.ProcessedAssignments e.ParameterList>
		(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
	>;
   
    (e.ProcessedAssignments)(e.NewEquations)((assign (weval s.type e.weval) ((par s.type e.refaldata))) e.ParameterList)e.Config=
        <DelExcAssgn1 
		(assign (weval s.type e.weval) ((par s.type e.refaldata)))
		<IfVarIsInEq (weval s.type e.weval) e.NewEquations e.ProcessedAssignments e.ParameterList>
		(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
	>;
*/
    (e.ProcessedAssignments)(e.NewEquations)((assign t.weval e.other) e.ParameterList) t.PRTC 
        = <DeleteExcessiveAssignments 
            (e.ProcessedAssignments(assign t.weval e.other))
            (e.NewEquations)
            ( e.ParameterList)
            t.PRTC
        >;
}

/*
    Вспомогательная для DeleteExcessiveAssignments
   Формат
   (assign (weval e e.var)(e.refaldata))
   s.Log
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   ((AreEqual ((s.Log)(e.Multiset)(e.WevalExpression))((s.Log)(e.Multiset)(e.WevalExpression)))^*)
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   (Desired e.calls)(e.Restrictions)(e.Assignments)((Delayed))(s.Log)
   =>
   ((AreEqual ((s.Log)(e.Multiset)(e.WevalExpression))((s.Log)(e.Multiset)(e.WevalExpression)))^*)
   ({(assign (weval e.var)(e.refaldata))|(assign (weval e.var)(e.MultisetOfWevals)(e.WevalExpression))}^*)
   (Desired e.calls)(e.Restrictions)(e.Assignments)((Delayed))(s.Log)
*/
DelExcAssgn1 {
    (assign t.weval t.refaldata)'F'(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
        =
        <DeleteExcessiveAssignments (e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config>;
    (assign t.weval t.refaldata)'T'(e.ProcessedAssignments)(e.NewEquations)(e.ParameterList)e.Config
        =
        <DeleteExcessiveAssignments (e.ProcessedAssignments (assign t.weval t.refaldata))(e.NewEquations)(e.ParameterList)e.Config>;
}

/*
    Подстановка данных рефала вместо представляющих их переменных типа weval.
	(([WordEquation]^*)
	((assign (weval e.vardata)(e.RefalExpr))|(assign (weval e.vardata)(e.Multiset)([WevalExpression]))^*)
        )
	[PRTC]
   => [PRTC]
*/


/*
    Разделение подстановок weval на подстановки в параметры, в иные рефал-данные и в другие переменные weval, 
    которые тут же применяются к подстановкам на рефал-данные.
   Вход:
   ((assign (weval e.vardata)(e.RefalExpr))^*)((assign (weval e.vardata)(e.Multiset)([WevalExpression]))^*)
   [(assign (weval e.vardata)(e.MultiSet)([WevalExpression]))|(assign (weval e.vardata)(e.RefalExpr))]^*
   Выход:
   (Restrictions (assign (par e.pardata)(e.Expr))^*)
   (Other (assign (var e.vardata)(e.Expr))|(assign (call e.calldata)(e.Expr))|(assign (weval e.vardata)(e.Expr))^*)
*/
SortWEAsgn {
    (e.RefalAsgn)(e.WEAsgn) = <FindParameterAssignments ()()e.RefalAsgn>;
    (e.RefalAsgn)(e.WEAsgn) (assign (weval e.data) (t.RefalData)) e.assignments
        = <SortWEAsgn 
            (e.RefalAsgn <SubstituteAllWEAsgnInRA ()(assign t.RefalData ((weval e.data))) e.WEAsgn e.assignments>
            )
            (e.WEAsgn)
            e.assignments
        >;
    (e.RefalAsgn)(e.WEAsgn) (assign (weval e.data)(e.Complexity)(e.Val)) e.assignments 
        =
        <SortWEAsgn 
            (e.RefalAsgn)(e.WEAsgn (assign (weval e.data)(e.Complexity)(e.Val))) e.assignments
        >;
}

/* Применение подстановок weval, связывающей его с другими weval, в подстановки на данные рефала. */
SubstituteAllWEAsgnInRA {
    (e.Processed)(assign t.RefalData ()) e.assignments = (assign t.RefalData (e.Processed));
	
    (e.Processed)(assign t.RefalData ((weval e.name) e.Val)) e.assignments 
        = 
        <SubstituteAllWEAsgnInRA1 
            <IfDecompWE (weval e.name) e.assignments>
            (e.Processed)(assign t.RefalData ((weval e.name) e.Val)) e.assignments
        >;

    (e.Processed)(assign t.RefalData (t.1 e.Val)) e.assignments
        = 
        <SubstituteAllWEAsgnInRA (e.Processed t.1)(assign t.RefalData (e.Val)) e.assignments>;
}

/* Ищем составное значение для переменной типа weval, описывающей конфигурацию рефал-данных. */
IfDecompWE {
	t.Var = ('F')t.Var;
	t.Var (assign t.WE t.RefalData)e.assignments = <IfDecompWE t.Var e.assignments>;
	t.Var (assign t.Var t.Complexity (e.Val)) e.assignments = ('T')(e.Val);
	t.Var (assign t.Var2 t.Complexity2 (e.Val)) e.assignments = <IfDecompWE t.Var e.assignments>;
}

SubstituteAllWEAsgnInRA1 {
    ('F')t.Var (e.Processed)(assign t.RefalData (t.Var e.Val)) e.assignments
        =
        <SubstituteAllWEAsgnInRA (e.Processed t.Var)(assign t.RefalData (e.Val)) e.assignments>;
    ('T')(e.VarVal) (e.Processed)(assign t.RefalData (t.Var e.Val)) e.assignments 
        =
        <SubstituteAllWEAsgnInRA (e.Processed)(assign t.RefalData (e.VarVal e.Val)) e.assignments>;
}		

/*
    Отделение подстановок параметров от прочих подстановок.
   Всем переменным типа weval, попадающим в описание этого параметра, ставятся в соответствие свежие параметры. 
*/

FindParameterAssignments {
    (e.FinalParAsgmts)(e.NParsgm) = (Restrictions e.FinalParAsgmts)(Other e.NParsgm);
/* 30.08.17 ДОРАБОТАТЬ!!! */
    (e.FinalParAsgmts)(e.NParAsgm)(assign (par e.pardata)(e.Val))e.other 
        = <FindParameterAssignments 
            <ChangeWevals2Pars (e.FinalParAsgmts)()()(assign (par e.pardata)(e.Val))> 
            e.NParAsgm e.other
        >;
    (e.FinalParAsgmts)(e.NParAsgm)(assign e.npa) e.other 
        = 
        <FindParameterAssignments (e.FinalParAsgmts)(e.NParAsgm (assign e.npa)) e.other>;
}

/*
    Как только оказывается, что параметр порождает новый параметр,
   все уже обработанные назначения не-параметров записываются в необработанные,
   и появляется новое назначение (assign (weval [type] [name])((par [type ][Fresh_ParInd]))),
   которое подставляется во все назначения, исключая назначения параметров, в
   которых уже не присутствуют переменные weval 
*/

ChangeWevals2Pars {
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)())e.other
        = (e.FinalAsgmts(assign (par e.pardata)(e.Processed)))() e.NewPars e.other;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((weval e e.vardata) e.Val))e.other 
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par e <FreshIndex 'pare_ind'>))
            (e.NewPars (assign (weval e e.vardata)((par e <CurrentIndex 'pare_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval e e.vardata)((par e <CurrentIndex 'pare_ind'>)))
            e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((weval t e.vardata) e.Val))e.other 
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par t <FreshIndex 'part_ind'>))
            (e.NewPars (assign (weval t e.vardata)((par t <CurrentIndex 'part_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval t e.vardata)((par t <CurrentIndex 'part_ind'>)))
                e.other>
            >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((weval s e.vardata) e.Val))e.other
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par s <FreshIndex 'pars_ind'>))
            (e.NewPars (assign (weval s e.vardata)((par s <CurrentIndex 'pars_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval s e.vardata)((par s <CurrentIndex 'pars_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((var e e.vardata) e.Val))e.other 
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par e <FreshIndex 'pare_ind'>))
            (e.NewPars (assign (var e e.vardata)((par e <CurrentIndex 'pare_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval e e.vardata)((par e <CurrentIndex 'pare_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((var t e.vardata) e.Val))e.other 
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par t <FreshIndex 'part_ind'>))
            (e.NewPars (assign (weval t e.vardata)((par t <CurrentIndex 'part_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval t e.vardata)((par t <CurrentIndex 'part_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)((var s e.vardata) e.Val))e.other
        =
        <ChangeWevals2Pars 
            (e.FinalAsgmts)
            (e.Processed (par s <FreshIndex 'pars_ind'>))
            (e.NewPars (assign (weval s e.vardata)((par s <CurrentIndex 'pars_ind'>))))
            (assign (par e.pardata)(e.Val))
            <SubstituteParsInWEAsgns 
                (assign (weval s e.vardata)((par s <CurrentIndex 'pars_ind'>)))
                e.other>
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)(('*' e.Val1) e.Val2))e.other 
        =
        <ContinueChW2P (e.Processed)(e.Val2) 
            <ChangeWevals2Pars
                (e.FinalAsgmts)()(e.NewPars)(assign (par e.pardata)(e.Val1))e.other
            >
        >;
    (e.FinalAsgmts)(e.Processed)(e.NewPars)(assign (par e.pardata)(t.1 e.Val))e.other
        =
        <ChangeWevals2Pars
            (e.FinalAsgmts)(e.Processed t.1)(e.NewPars)(assign (par e.pardata)(e.Val))e.other
        >;
}

/* Закончили порождать параметры в скобках - соединяем результаты и продолжаем вне скобок. */
ContinueChW2P {
    (e.BefBrack)(e.AfterBrack)(e.FinalAsgmts(assign (par e.pardata)(e.InBrack)))() e.other 
        =
        <ChangeWevals2Pars (e.FinalAsgmts)(e.BefBrack ('*' e.InBrack))()(assign (par e.pardata)(e.AfterBrack))e.other>;

}
/* Подстановка вновь порожденного параметра в назначение, полученное из уравнений в словах. */
SubstituteParsInWEAsgns {
    t.NewPar = ;
    t.NewPar (assign t.RefalData (e.Val)) e.other
        =
        (assign t.RefalData (<Substitute t.NewPar e.Val>)) <SubstituteParsInWEAsgns t.NewPar e.other>;
}

/*******************************************************************************************
   ФУНКЦИИ ПЕРВИЧНОГО АНАЛИЗА УРАВНЕНИЙ В СЛОВАХ
********************************************************************************************/


/*
    Если имеются уравнения, в которых можно что-то уточнить - уточняем,
   иначе возвращаем всю конфигурацию. 
*/

OptimizeEquations {
/*
    	(e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log) =
		<OptimizeEquations1 (<IfProcessible () e.equations>) (e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log)>; 
*/
	t.PRTC = t.PRTC;
}

/*
    Пока что здесь действие отменено. Подразумевается, что дополнительная проверка на данном этапе не дает никаких новых
   возможностей уточнить уравнения. 
*/

OptimizeEquations1 {
/*
    	((e.PrEq)(e.equations1)'T')(e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log)=
		<OptimizeEquations 
			<ProcessEqualityLeft (e.equations1)(e.restrictions)(e.assignments)(e.Clashes)(s.Log)(e.PrEq)>
		>; 
*/

    ((e.PreQ)(e.equations1)s.NotT)(e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log)
        =
        (e.equations)(e.restrictions)(e.assignments)(e.Clashes)(s.Log);
}

SubstituteAllNewData {
     t.PRTC
     , <GetPRTCRestrs t.PRTC> : e.Restrs
     , <GetPRTCAsgs t.PRTC> : e.Asgs
          = <SubstInAllEqs (e.Restrs) <SubstInNewEqs (e.Asgs) t.PRTC>>;
}

/*******************************************************************************************
   ФУНКЦИИ СОПОСТАВЛЕНИЯ В ПРОГОНКЕ
********************************************************************************************/


$ENTRY Drive {
/* 1. Гроздь прогонки, соответствующая данному правилу, построена. */
    (e.ProcPRTC) = e.ProcPRTC;
/*
    2. Имеется тождественное сопоставление. Все сопоставления, следующие за ним, не рассматриваются!
   Такие случаи могут возникнуть из-за наличия в образцах свободных е-переменных! 
*/

    /*   (e.ProcPRTC) t.PRTC e.OtherPRTC, 
    <GetPRTCClash t.PRTC> : ,
    <GetPRTCRestrs t.PRTC> :
         = e.ProcPRTC <SolveEquations t.PRTC>; 
*/

/*
    3. Имеется неразрешенное сопоставление из-за наличия в нём вызовов, существенно
   задействованных при его решении.
   ВНИМАНИЕ! Не смотрим на распределение параметров, сразу считаем, что нужно выталкивать эти вызовы. 
*/
    (e.ProcPRTC) t.PRTC e.OtherPRTC, 
    <GetPRTCClash t.PRTC> : ,
    <SolveEquations t.PRTC> :
    { /* EMPTY */ = <AAA><Putout 1 'PRTC failed in equation block:'><Putout 1 t.PRTC><Putout 1><Drive (e.ProcPRTC) e.OtherPRTC>;
        t.CurrentPRTC,
        <Putout 1 'Testing negative block: '><Putout 1 t.CurrentPRTC><Putout 1> : ,
            <TestNegativeBlock t.CurrentPRTC> :            
                { /* EMPTY */
                    = <Putout 1 'PRTC failed in negative block:'><Putout 1 t.PRTC><Putout 1><Drive (e.ProcPRTC) e.OtherPRTC>;
                t.NewPRTC
                =
                <Putout 1 'PRTC is completely processed:'><Putout 1 t.PRTC><Putout 1 ' to'><Putout 1 t.NewPRTC>
                <Drive (e.ProcPRTC t.NewPRTC) e.OtherPRTC>;
        };
    };
    
/* 4. Сопоставление еще не завершено. */
    (e.ProcPRTC) t.PRTC e.OtherPRTC
        = <Drive (e.ProcPRTC) <ClashLeft 0 t.PRTC> e.OtherPRTC>;
}

DeleteEmpty {
    e.1 (OR ) e.2 = e.1 <DeleteEmpty e.2>;
    e.Z = e.Z;
}

TestNegativeBlock {
    t.PRTC,
        <GetPRTCNegativeInfo t.PRTC> : 
        {(OR e.Clashes) e.OtherClashes,
        <DeleteEmpty (OR e.Clashes) e.OtherClashes> : e.NewClashes
            = <TestNegativeBlock Started ()t.PRTC e.NewClashes>;
        /* EMPTY */ = t.PRTC;
        };
    Started (e.ProcessedNegative) t.PRTC
        = <ReplacePRTCNegativeInfo t.PRTC e.ProcessedNegative>;
    Started (e.ProcessedNegative) t.PRTC (OR e.Clashes) e.OtherClashes,
        <GetPRTCRestrs t.PRTC> : e.Restrs,
        <IterateSubstitute (e.Restrs)e.Restrs> : e.SubRestrs,
        <SubstituteInClashes 0 (e.SubRestrs) e.Clashes (Delayed)> : e.NewClashes (Delayed),
        <GenerateFreshPRTC e.NewClashes> : t.NegativePRTC,
        <Drive () <ClashLeft 0 t.NegativePRTC>>
        : { 
            /* EMPTY */ 
                = <TestNegativeBlock Started (e.ProcessedNegative) t.PRTC e.OtherClashes>;
            e.PRTCs,
            <TrivialPRTC e.PRTCs> : 'T'
                = /* EMPTY */ ;
            e.PRTCsWithRestrictions
                = <TestNegativeBlock Started (e.ProcessedNegative (OR e.NewClashes)) t.PRTC e.OtherClashes>;
        };
}

AddTrivRestrs {
    (e.Expression)e.Restrs,
    <GetParList ()e.Expression> : e.ActivePars
        = <AddTrivRestrs Started (e.ActivePars)e.Restrs> e.Restrs;
    Started(e.ActPars1 t.par e.ActPars2)(assign t.par (e.Expr))e.OtherRestrs
        = <AddTrivRestrs Started(e.ActPars1 e.ActPars2)e.OtherRestrs>;
    Started(e.ActPars)(assign t.par (e.Expr))e.OtherRestrs
        = <AddTrivRestrs Started(e.ActPars)e.OtherRestrs>;
    Started(e.ActivePars)
        = <AddTrivRestrs Continued e.ActivePars>;
    Continued t.par e.Other = (assign t.par (t.par))<AddTrivRestrs Continued e.Other>;
    Continued = ;
 }

TrivialPRTC {
     = 'F';
     t.PRTC e.PRTCs
     , <GetPRTCRestrs t.PRTC> : /* EMPTY */ 
     , <GetPRTCNewEqs t.PRTC> : /* EMPTY */
         = 'T';
    t.PRTC e.PRTCs = <TrivialPRTC e.PRTCs>;
}

FreeNonRepeatedVariables {
    e.Pattern1 ('*' e.InBr) e.Pattern2 = <FreeNonRepeatedVariables e.Pattern1 e.InBr e.Pattern2>;
    e.1 (var t.type (t.Name)) e.2 = 'F';
    e.1 (var t.Type t.Name) e.2 (var t.Type t.Name) e.3 = 'F';
    e.1 (var e t.Name) e.2 (var e t.Name2) e.3 = 'T';
    e.Z = 'F';
}

SubstituteNewRestrictionWithNegativeData {
    (assign (par e e.pardata) (e.Val)) t.PRTC
    , <GenerateNewParameterAssignments ()() e.Val> : 
        {   
        (e.newasgmnts)(e.NewVal) 
            = <Putout 1 'Adding negative info from: ' e.NewVal>
                <AddPRTCNegativeInfo 
                <SubstituteNewRestrictionAux (assign (par e e.pardata) (e.NewVal))
			<ReplacePRTCAsgs t.PRTC e.newasgmnts> 
                > (OR <ExtractNegativeFromFree e.NewVal>)
            >;    
        };
}

ExtractNegativeFromFree {
    e.0 (par e t.Name) s.1 e.1 (par e t.Name2) e.2 
        = (((par e t.Name)) to ((var e (<Implode 'Exp'<Symb <FreshIndex 'vare_ind'>>>))s.1 e.1 (var e (<Implode 'Exp'<Symb <FreshIndex 'vare_ind'>>>))));
    e.Z = ;
}

/*
   Основная функция прогонки.
   s.Mode [PRTC]=>[PRTC]^*
   s.Mode ::= 0|1\2 - здесь 0 указывает на процесс сопоставления слева, 1 - справа, 2 - на сопоставление открытых е-переменных.
   e.equations ::= ((AreEqual ((s.Log1) e.Expr1)((s.Log2) e.Expr2))^* (Desired (AreEqual ((s.Log1) (call e.Call))((s.Log2) e.Expr4Call))))
   e.Expr4Call могут содержать переменные шаблона!
   
   e.restrictions ::= (assign (par e.pardata) (e.Val))^* //e.Val не содержит переменных шаблона
   e.assignments ::= (assign (var e.vardata) (e.Val))^* //e.Val не содержит переменных шаблона
   e.clashes ::= ((e.Expr) to (e.Pattern))^* (Delayed ((e.Expr) to (e.Pattern))^*) // e.Expr не содержит переменных шаблона, e.Pattern - параметров и вызовов
*/
$ENTRY ClashLeft {
/* 1. Удаление неудачного сопоставления. */
	s.Mode t.PRTC, <IsContradictory t.PRTC> : 'T' = ;

/* 2. Результат успешного сопоставления без отложенных сопоставлений и без уравнений - оставляем всё как есть. */
	s.Mode t.PRTC
        , <GetPRTCClash t.PRTC> : /* EMPTY */
        , <GetPRTCNewEqs t.PRTC> :
        {
        /* EMPTY */
        , <GetPRTCRestrs t.PRTC> : /* EMPTY */ 
                = t.PRTC;
        e.Other = <SubstituteAllNewData t.PRTC>;
        };

/* 4. Удаление пустого сопоставления. */
    s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : (() to ())
        =
        <ClashLeft <ResetMode s.Mode>
            <DeleteLastPRTCClash t.PRTC>
        >;
/* 5. Единственная е-переменная - сохраняем в назначениях. */
    s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to ((t.class2 e e.vardata)))
    , <GetPRTCAsgs t.PRTC> : e.assignments 
        =
        <ClashLeft <ResetMode s.Mode>
                <AddNewAssignment 
                    <CheckNewAssignment (assign (t.class2 e e.vardata) (e.Expr))(e.assignments)>
                        <DeleteLastPRTCClash t.PRTC>>
        >;
/* 6. Единственный е-параметр - ЭКСПЕРИМЕНТАЛЬНАЯ ВЕРСИЯ! */
    s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : (((par e e.pardata)) to (e.Pattern))
    , <GetPRTCAsgs t.PRTC> : /* EMPTY */
    , <FreeNonRepeatedVariables e.Pattern> : 'T'
    , <GetPRTCAllClashes t.PRTC> : (((par e e.pardata)) to (e.Pattern))(Delayed )
        =       
        <ClashLeft <ResetMode s.Mode>
                <SubstituteNewRestrictionWithNegativeData 
                        (assign (par e e.pardata) (e.Pattern))
                        <DeleteLastPRTCClash t.PRTC>>
        >;

/* 6. Единственный е-параметр - порождаем новое сужение по образцу. */
    s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : (((par e e.pardata)) to (e.Pattern))
    , <GetPRTCAsgs t.PRTC> : e.assignments 
        =
        <ClashLeft <ResetMode s.Mode>
                <SubstituteNewRestriction 
                        (assign (par e e.pardata) (e.Pattern))
                        <DeleteLastPRTCClash t.PRTC>>
        >;
                
/* 7. 11.06.ИЗМЕНЕНО! Выражение равно пустому образцу - все термы выражения пусты. */
    s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to ()) 
        =
        <ClashLeft <ResetMode s.Mode>
            <PutPRTCNewEq 
                <DeleteLastPRTCClash t.PRTC> 
                (AreEqual ('T')(e.Expr)())
            >
        >;
/* 8. Пустое выражение сопоставляется образцу, начинающемуся с е-переменной - эта е-переменная пуста. */
    s.Mode t.PRTC
    , <GetPRTCClash t.PRTC> : (() to (t.Term e.Pattern))
    , <GetPRTCAsgs t.PRTC> : e.assignments
    , t.Term :
        {
        (t.class2 e e.vardata) 
            = <ClashLeft <ResetMode s.Mode> <PutPRTCClash <AddNewAssignment 
                            <CheckNewAssignment (assign (t.class2 e e.vardata) ())(e.assignments)>
                                <DeleteLastPRTCClash t.PRTC>>(() to (e.Pattern))
            >>;
        t.Other = <ClashLeft 0 <NullifyPRTC>>;
        };

/* 9. Если сопоставляются термы, вызываем функцию сопоставления термов. */
    0 t.PRTC
    , <GetPRTCClash t.PRTC> : ((t.1 e.Expr) to (t.2 e.Pattern))
    , <IsTerm t.1> : 'T'
    , <IsTerm t.2> : 'T' 
        =
        <ClashLeft 0 
            <ClashSymb 
                ((t.1) to (t.2)) 
                <PutPRTCClash <DeleteLastPRTCClash t.PRTC> ((e.Expr) to (e.Pattern))>>>;
    1 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr t.1) to (e.Pattern t.2))
    , <IsTerm t.1> : 'T'
    , <IsTerm t.2> : 'T'
        =
        <ClashLeft 1
            <ClashSymb 
                ((t.1) to (t.2)) 
                <PutPRTCClash <DeleteLastPRTCClash t.PRTC> ((e.Expr) to (e.Pattern))>>>;

/* 10. Если сопоставляется е-переменная и идет сопоставление слева, вызываем сопоставление справа. */
    0 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to ((t.class2 e e.vardata) e.Pattern)) 
        = <ClashLeft 1 t.PRTC>;
        
/* 11. Если сопоставляется е-переменная и идет сопоставление справа, переходим в разбор по е-переменной слева. */
    1 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to (e.Pattern (t.class2 e e.vardata)))
        = <ClashLeft 2 t.PRTC>;

/* 12. Если пошло сопоставление по е-переменной - вызываем функцию сопоставления е-переменных. */
    2 t.PRTC
    , <GetPRTCClash t.PRTC> : ((t.1 e.Expr) to ((t.class2 e e.vardata) e.Pattern))
        = 
        <ClashEvar 2 ((t.1) to ((t.class2 e e.vardata)))((e.Expr) to (e.Pattern)) <DeleteLastPRTCClash t.PRTC>>;
    2 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr) to (e.Pattern))
        = 
        <ClashLeft 3 t.PRTC>;
    3 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr t.1) to (e.Pattern (t.class2 e e.vardata)))
        = 
        <ClashEvar 3 ((t.1) to ((t.class2 e e.vardata)))((e.Expr) to (e.Pattern)) <DeleteLastPRTCClash t.PRTC>>;

/* 12. В противном случае вызываем общую функцию сопоставления (слева или справа). */
    0 t.PRTC
    , <GetPRTCClash t.PRTC> : ((t.1 e.Expr) to (t.2 e.Pattern))
        =
        <ClashLeftGeneric 0 ((t.1) to (t.2))((e.Expr) to (e.Pattern)) <DeleteLastPRTCClash t.PRTC>>;
    1 t.PRTC
    , <GetPRTCClash t.PRTC> : ((e.Expr t.1) to (e.Pattern t.2))
        =
        <ClashLeftGeneric 1 ((t.1) to (t.2))((e.Expr) to (e.Pattern)) <DeleteLastPRTCClash t.PRTC>>;
}


ResetMode {
    0 = 0;
    1 = 0;
    2 = 0;
    3 = 0;
    5 = 5;
    6 = 5;
     7 = 5;
    8 = 5;
}

ClassIdentifier {
    var e = 'vare_ind';
    var t = 'vart_ind';
    var s = 'vars_ind';
    par e = 'pare_ind';
    par t = 'part_ind';
    par s = 'pars_ind';
    weval e = 'wevale_ind';
    weval t = 'wevalt_ind';
    weval s = 'wevals_ind';
}

/*
    Функция, сопоставляющая термы. Обрабатывает только случаи, когда 
   слева и справа символы, термы, термовые и символьные переменные и параметры.
   Эта часть не порождает новых вариантов конфигурации. 
*/

ClashSymb {
/* 1. символ - символ. */
	((s.Sym) to (s.Sym)) t.PRTC = t.PRTC;

/* 2. выражение в скобках - выражение в скобках. */
	((('*'e.Expr1)) to (('*'e.Pat1))) t.PRTC = <PutPRTCClash t.PRTC ((e.Expr1) to (e.Pat1))>;

/* 3. Переменная (s- или t-) с термом, не порождающим сужение. */
	((t.1) to ((t.class e.vardata)))t.PRTC,
        <LessGenericPattern t.1 (t.class e.vardata)> : 'F',
        <GetPRTCAsgs t.PRTC> : e.assignments 
            =
            <AddNewAssignment 
                <CheckNewAssignment (assign (t.class e.vardata) (t.1))(e.assignments)>
                    t.PRTC >;
/* 4. символ - t-параметр. */
	(((t.class t e.pardata)) to (s.Sym)) t.PRTC
            = 
            <SubstituteNewRestriction 
                (assign (t.class t e.pardata) (s.Sym))
                t.PRTC >;
/* 5. символ - s-параметр. */
	(((t.class s e.pardata)) to (s.Sym)) t.PRTC
            =
            <SubstituteNewRestriction 
                (assign (t.class s e.pardata) (s.Sym))
                t.PRTC >;

/* 6. s-переменная - t-параметр. Сужение t-параметра до (свежего) s-параметра. */
	(((t.class t e.pardata)) to ((t.class2 s e.vardata))) t.PRTC,
        <GetPRTCAsgs t.PRTC> : e.assignments,
        <FreshIndex <ClassIdentifier t.class s>> : t.snew
            =
            <AddNewAssignment 
                <CheckNewAssignment 
                    (assign (t.class2 s e.vardata) ((t.class s t.snew)))
                    (e.assignments)
                >
                <SubstituteNewRestriction 
                    (assign (t.class t e.pardata) ((t.class s t.snew))) 
                    t.PRTC
                >
            >;
/* 7. выражение в скобках - t-параметр. */
	(((t.class t e.pardata)) to (('*'e.InBracks))) t.PRTC,
            <GetPRTCAsgs t.PRTC> : e.assignments
            = 
            <SubstituteNewRestriction 
                (assign (t.class t e.pardata) (('*'<Substitute (e.assignments)e.InBracks>))) t.PRTC
            >;

/* 8. В остальных случаях конфигурация противоречива. */
	t.Clash t.PRTC = <NullifyPRTC>;
}

/* Функция сопоставления е-переменных. */
ClashEvar {
/*
    1. терм - е-переменная.
   Внимание!! Случаи не обрабатываются совместно. Они не содержат существенных сужений! Поэтому
   каждый из них может оказаться тождественно выполним, и тогда другие обрабатывать не надо! 
*/
	s.Mode ((t.Obj) to ((t.class2 e e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC,
        <IsTerm t.Obj> : 'T',
        <GetPRTCAsgs t.PRTC> : e.assignments,
        <FreshIndex <ClassIdentifier t.class2 e>> : t.venew
            =
            <ClashLeft <Sub s.Mode 2>
                <AddNewAssignment 
                    <CheckNewAssignment (assign (t.class2 e e.vardata) ())(e.assignments)> 
                    <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode t.Obj e.Expr>) to (e.Pattern))>
                >
            >	
            <ClashLeft <Sub s.Mode 2> 
                <AddNewAssignment 
                    <CheckNewAssignment (assign (t.class2 e e.vardata) (<ShuffleMode s.Mode t.Obj (t.class2 e (t.venew))>))(e.assignments)> 
                    <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 e (t.venew)) e.Pattern>))>
                >
            >;
/*
    2. е-параметр - е-переменная. Три случая по приоритетам:
   1) e-переменная пуста;
   2) е-параметр содержит всю е-переменную и еще что-то непустое;
   3) е-переменная содержит весь е-параметр и еще что-то непустое.
   Внимание!! Случаи не обрабатываются совместно. Они не содержат существенных сужений! Поэтому
   каждый из них может оказаться тождественно выполним, и тогда другие обрабатывать не надо!
*/
	s.Mode (((t.class e e.pardata)) to ((t.class2 e e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC,
        <GetPRTCAsgs t.PRTC> : e.assignments,
        <FreshIndex <ClassIdentifier t.class2 e>> : t.venew,
        <FreshIndex <ClassIdentifier t.class e>> : t.penew1,
        <FreshIndex <ClassIdentifier t.class e>> : t.penew2,
        <FreshIndex <ClassIdentifier t.class t>> : t.ptnew,
        <FreshIndex <ClassIdentifier t.class t>> : t.ptnew2,
        <FreshIndex <ClassIdentifier t.class2 t>> : t.vtnew        
		= <ClashLeft <Sub s.Mode 2>
			<AddNewAssignment 
				<CheckNewAssignment (assign (t.class2 e e.vardata) ())(e.assignments)> 
                                <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class e e.pardata) e.Expr>) to (e.Pattern))>
			>	
		>
                <ClashLeft <Sub s.Mode 2>
                    <AddNewAssignment 
                        <CheckNewAssignment 
                            (assign (t.class2 e e.vardata) 
                                (<ShuffleMode s.Mode (t.class e t.penew1)(t.class t t.ptnew)>))(e.assignments)
                        > 
                        <SubstituteNewRestriction 
                            (assign (t.class e e.pardata) 
                                (<ShuffleMode s.Mode (t.class e t.penew1) <ShuffleMode s.Mode (t.class t t.ptnew)<ShuffleMode s.Mode (t.class t t.ptnew2)(t.class e t.penew2)>>>))
                            <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class t t.ptnew2) <ShuffleMode s.Mode (t.class e t.penew2) e.Expr>>) to (e.Pattern))>
                        >
                >>
                <ClashLeft <Sub s.Mode 2>
                    <AddNewAssignment 
                        <CheckNewAssignment (assign (t.class2 e e.vardata) ((t.class e e.pardata)))(e.assignments)>
                            <PutPRTCClash t.PRTC ((e.Expr) to (e.Pattern))>
                    >
                >
                <ClashLeft <Sub s.Mode 2>
                    <AddNewAssignment 
                        <CheckNewAssignment (assign (t.class2 e e.vardata) 
                            (<ShuffleMode s.Mode (t.class e e.pardata)<ShuffleMode s.Mode (t.class2 t (t.vtnew))(t.class2 e (t.venew))>>))(e.assignments)> 
                        <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 t (t.vtnew))<ShuffleMode s.Mode (t.class2 e (t.venew)) e.Pattern>>))>
                >
                
                >;
/*
    2. вызов - е-переменная. Три случая по приоритетам:
   1) e-переменная пуста;
   2) вызов содержит всю е-переменную и еще что-то непустое;
   3) е-переменная содержит весь вызов.
   Внимание!! Случаи не обрабатываются совместно. Они не содержат существенных сужений! Поэтому
   каждый из них может оказаться тождественно выполним, и тогда другие обрабатывать не надо!
*/
    s.Mode (((call e.call)) to ((var e e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC,
    <GetPRTCAsgs t.PRTC> : e.assignments
        = 
        <ClashLeft <Sub s.Mode 2>
            <AddNewAssignment 
                <CheckNewAssignment (assign (var e e.vardata) ())(e.assignments)> 
                <PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (call e.call) e.Expr>) to (e.Pattern))>
            >	
        >
        <ProcessDelayedCallsInClash
            t.PRTC
            (AreEqual ('T')(<ShuffleMode s.Mode (call e.call)e.Expr>)(<ShuffleMode s.Mode (var e e.vardata) e.Pattern>))
        >;
/* 8. В остальных случаях конфигурация противоречива. */
	t.Clash t.PRTC = <ClashLeft 0 <NullifyPRTC>>;
}

$ENTRY ShuffleMode {
    0 t.1 e.1 = t.1 e.1;
    1 t.1 e.1 = e.1 t.1;
    2 t.1 e.1 = t.1 e.1;
    3 t.1 e.1 = e.1 t.1;
}

/*
    Функция, продолжающая работу ClashLeft на непустых e.Pattern и e.Expr, содержащих хотя бы с одной
   стороны неизвестную произвольной длины (параметр, переменную е-типа) либо вызов функции. 
*/

ClashLeftGeneric {
/*
    1. символ - e-параметр.
   Два случая - сужение е-параметра до символа + е-параметра 
   и сужение е-параметра до пустой строки.
*/
	s.Mode (((t.class e e.pardata)) to (s.Sym))((e.Expr) to (e.Pattern)) t.PRTC,
        <FreshIndex <ClassIdentifier t.class e>> : t.enew
                = <ClashLeft s.Mode
			<SubstituteNewRestriction 
					(assign (t.class e e.pardata) (<ShuffleMode s.Mode s.Sym (t.class e t.enew)>))				
					<PutPRTCClash t.PRTC
                                            ((<ShuffleMode s.Mode (t.class e t.enew)e.Expr>) to (e.Pattern))>
			>
		>
		<ClashLeft s.Mode
			<SubstituteNewRestriction 
					(assign (t.class e e.pardata) ())
					<PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode s.Sym e.Pattern>))>
			>	
		>;

/*
    2. s-переменная - e-параметр.
   Два случая - сужение е-параметра до s-параметра + е-параметра (а s-переменной - до s-параметра)
   и сужение е-параметра до пустой строки.
*/
	s.Mode (((t.class e e.pardata)) to ((t.class2 s e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC,
        <GetPRTCAsgs t.PRTC> : e.assignments,
        <FreshIndex <ClassIdentifier t.class e>> : t.enew,
        <FreshIndex <ClassIdentifier t.class s>> : t.snew
		= <ClashLeft s.Mode 
			<AddNewAssignment 
				<CheckNewAssignment (assign (t.class2 s e.vardata) ((t.class s t.snew)))(e.assignments)> 
				<SubstituteNewRestriction 
					(assign (t.class e e.pardata) (<ShuffleMode s.Mode (t.class s t.snew)(t.class e t.enew)>))
					<PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class e t.enew)e.Expr>) to (e.Pattern))>
				>
			>
		>
		<ClashLeft s.Mode
			<SubstituteNewRestriction 
					(assign (t.class e e.pardata)()) 
					<PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 s e.vardata) e.Pattern>))>
			>	
		>;
/*
    3. t-переменная - e-параметр. 
   Два случая - сужение е-параметра до t-параметра + е-параметра (а t-переменной - до t-параметра)
   и сужение е-параметра до пустой строки.
*/
	s.Mode (((t.class e e.pardata)) to ((t.class2 t e.vardata)))((e.Expr) to (e.Pattern)) t.PRTC,
        <GetPRTCAsgs t.PRTC> : e.assignments,
        <FreshIndex <ClassIdentifier t.class e>> : t.enew,
        <FreshIndex <ClassIdentifier t.class t>> : t.tnew
		= <ClashLeft s.Mode
			<AddNewAssignment 
				<CheckNewAssignment (assign (t.class2 t e.vardata) ((t.class t t.tnew)))(e.assignments)> 
				<SubstituteNewRestriction 
					(assign (t.class e e.pardata) (<ShuffleMode s.Mode (t.class t t.tnew)(t.class e t.enew)>))
					<PutPRTCClash t.PRTC ((<ShuffleMode s.Mode (t.class e t.enew)e.Expr>) to (e.Pattern))>
				>
			>
		>
		<ClashLeft s.Mode
			<SubstituteNewRestriction 
					(assign (t.class e e.pardata) ())
					<PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode (t.class2 t e.vardata) e.Pattern>))>
			>	
		>;

/* 4. Выражение в скобках - е-параметр. */
	s.Mode (((t.class e e.pardata)) to (('*'e.Pat1)))((e.Expr) to (e.Pat2))t.PRTC,
        <FreshIndex <ClassIdentifier t.class e>> : t.enew1,
        <FreshIndex <ClassIdentifier t.class e>> : t.enew2
		= <ClashLeft s.Mode
			<SubstituteNewRestriction 
					(assign (t.class e e.pardata) 
						(<ShuffleMode s.Mode ('*'(t.class e t.enew1))(t.class e t.enew2)>)
					)
					<PutPRTCClash
                                            <PutPRTCClash t.PRTC (((t.class e t.enew1)) to (e.Pat1))>
						((<ShuffleMode s.Mode (t.class e t.enew2)e.Expr>) to (e.Pat2))>
                        >
		>
		<ClashLeft s.Mode
			<SubstituteNewRestriction 
					(assign (t.class e e.pardata) ())
                                        <PutPRTCClash t.PRTC ((e.Expr) to (<ShuffleMode s.Mode ('*'e.Pat1) e.Pat2>))>			
			>	
		>;

/* 5. Образец сопоставляется с единственным вызовом. */
	s.Mode (((call e.call)) to (t.PatternPart))(() to (e.Pat2)) t.PRTC,
        <GetPRTCAsgs t.PRTC> : e.assignments,
        <Substitute (e.assignments) <ShuffleMode s.Mode t.PatternPart e.Pat2>> : e.NewExpr
            =
            <ClashLeft s.Mode
                <ProcessNewSimpleCallCondition 
                    (<IfGround (e.NewExpr)>)
                    (AreEqual ('F')((call e.call))(e.NewExpr))
                    t.PRTC
                >
            >;
/* 6а. Выражение в скобках - вызов. Если шло сопоставление слева, вызываем сопоставление справа. */
        0 (((call e.call)) to (('*'e.Pat1)))((e.Expr) to (e.Pat2)) t.PRTC
            =
            <ClashLeft 1
                <PutPRTCClash t.PRTC (((call e.call)e.Expr) to (('*'e.Pat1) e.Pat2))>
            >;
/*
    6б. Выражение в скобках - вызов. Если шло сопоставление справа - делим на два случая, в одном вызов вычисляется
   в пустое выражение, в другом - в выражение, оканчивающееся выражением в скобках. 
*/

        1 (((call e.call)) to (('*'e.Pat1)))((e.Expr) to (e.Pat2)) t.PRTC,
        <FreshIndex <ClassIdentifier weval e>> : t.wevalnew
		= <ClashLeft 1 
                    <ProcessNewSimpleCallCondition 
                        ('T')
                        (AreEqual ('F')((call e.call))()) 
                        <PutPRTCClash t.PRTC ((e.Expr) to (e.Pat2 ('*'e.Pat1)))>>
                >
                <ProcessDelayedCallsInClash
                        <ProcessNewSimpleCallCondition
                            ('F')
                            (AreEqual ('F')((call e.call))((weval e t.wevalnew)('*'e.Pat1)))
                            t.PRTC
                        >
                        (AreEqual ('T')(e.Expr(weval e t.wevalnew))(e.Pat2))
                >;

/*
    7а. терм (термовый параметр либо символ) - вызов: два варианта - пустой либо терм+е-неизвестная. Если шло
   сопоставление слева - переходим на сопоставление справа. 
*/

	0 (((call e.call)) to (t.PattPart))((e.Expr) to (e.Pattern)) t.PRTC,
        <IsTerm t.PattPart> : 'T'
		= <ClashLeft 1
			    <PutPRTCClash t.PRTC (((call e.call)e.Expr) to (t.PattPart e.Pattern))>
                >;
/* 7б. терм (термовый параметр либо символ) - вызов, сопоставление справа: два варианта - пустой либо терм+е-неизвестная. */
	1 (((call e.call)) to (t.PattPart))((e.Expr) to (e.Pattern)) t.PRTC,
        <IsTerm t.PattPart> : 'T',
        <FreshIndex <ClassIdentifier weval e>> : t.wevalnew 
		= <ClashLeft 1 
                    <ProcessNewSimpleCallCondition 
                        ('T')
                        (AreEqual ('F')((call e.call))()) 
                        <PutPRTCClash t.PRTC ((e.Expr) to (e.Pattern t.PattPart))>
                    >
                >
                <ProcessDelayedCallsInClash
                        <ProcessNewSimpleCallCondition
                            ('F')
                            (AreEqual ('F')((call e.call))((weval e t.wevalnew)t.PattPart))
                            t.PRTC
                        >
                        (AreEqual ('T')(e.Expr(weval e t.wevalnew))(e.Pattern))
                >;

/* 8. все прочие варианты - сопоставление невыполнимо и коллапсирует. */
	s.Mode t.Clash t.PRTC = <ClashLeft 0 <NullifyPRTC>>;
}

/*
    Функция введена для того чтобы неопределенные вызовы слева и справа в выражении,
   сопоставляемом образцу, обрабатывались одинаково. Вызывается только при сопоставлении
   вызова справа выражения объектному терму, в случае, если вызов отождествляется не с пустым выражением. 
   Если слева тоже стоит вызов и объектный терм, порождает два варианта сопоставления:
   вызов есть пустое выражение и вызов непуст. 
*/

ProcessDelayedCallsInClash {
    t.PRTC (AreEqual (s.Log)((call e.call)e.Expr)(t.Term e.Pattern)),
    <IsTerm t.Term> : 'T',
    <FreshIndex <ClassIdentifier weval e>> : t.wevalnew
        = <ClashLeft 0 
            <ProcessNewSimpleCallCondition
            ('T')
            (AreEqual ('F')((call e.call))())
            <PutPRTCClash 
                t.PRTC 
                ((e.Expr) to (t.Term e.Pattern))
            >
            >
        >
        <ClashLeft 0 
            <PutPRTCNewEq 
            <ProcessNewSimpleCallCondition
            ('F')
            (AreEqual ('F')((call e.call))(t.Term (weval e t.wevalnew)))
            t.PRTC
            >
            (AreEqual ('T')((weval e t.wevalnew) e.Expr)(e.Pattern))
        >
        >;
    t.PRTC t.OtherEquation
        = <ClashLeft 0 <PutPRTCNewEq t.PRTC t.OtherEquation>>;
}


/*
   Выделение тех отложенных сопоставлений, в которые были внесены упрощающие изменения.
   [PRTC]=>[PRTC]
*/
FindProcessibleClashes {
/*
    1. Данное отложенное сопоставление содержит существенные изменения по сравнению с исходным отложенным вариантом -
   новая попытка разрешения. 
*/

	t.PRTC,
        <GetPRTCDelayedCl t.PRTC> : e.Del1 (('T')e.Clash) e.Del2 
            = <ClashLeft 0 <PutPRTCClash <ReplacePRTCDelayedCl t.PRTC e.Del1 e.Del2> (e.Clash)>>;
/* 2. Отложенных сопоставлений не осталось. */
	t.PRTC = t.PRTC;
}

/*
    Обработка равенства вызова и куска образца:
    если кусок образца - константное выражение, подстановка его вместо вызова и сохранение равенства в Desired.
    Иначе просто сохранение равенства в Desired.
*/
ProcessNewSimpleCallCondition {
	('T')(AreEqual e.CallEq) t.PRTC,
        e.CallEq : ('F')((call e.call))(e.Pattern)
            =
		<SubstituteCallFormat (assign (call e.call) (e.Pattern))
                    <PutPRTCCallRestr t.PRTC (AreEqual e.CallEq)>
                >;

        ('F')(AreEqual e.CallEq) t.PRTC = <PutPRTCCallRestr t.PRTC (AreEqual e.CallEq)>;
}

/* Добавление нескольких подстановок новой переменной образца. */
AddAssignments {
    t.PRTC (assign e.asg) e.otherasgs,
        <GetPRTCAsgs t.PRTC> : e.assignments 
        =  <AddNewAssignment 
                <CheckNewAssignment (assign e.asg)(e.assignments)>
                t.PRTC
            >;
    t.PRTC = t.PRTC;
} 

/*
    Добавление подстановки новой переменной образца
   (assign (var e.vardata)(e.Expr){or (e.Expr)}^*)[PRTC] =>
   [PRTC]
   
   Если она уникальна - просто подстановка в равенства.
   Иначе помещаем соответствующее уравнение в блок уравнений. 
*/

AddNewAssignment {
/* 1. Подстановка единственна - добавляем в блок. */
        (assign (t.class e.vardata)(e.Expr)) t.PRTC,
        <PutPRTCAsg t.PRTC (assign (t.class e.vardata)(e.Expr))> : t.PRTC0 
            = t.PRTC0;
        (assign (t.class e.vardata)t.Expr or t.Expr) t.PRTC
            = t.PRTC;
/*
   2. Подстановка повторна, но новая подстановка определяет равенство между параметрами - выбираем вновь
   порожденный параметр и поставляем вместо него более старый. В двух вариантах. 
*/

	(assign (var e.vardata)((par s.type t.Name1)) or ((par s.type t.Name2))) t.PRTC,
        <MyIfNotLess t.Name2 <Add <CurrentIndex 'dpar'<Explode s.type>'_ind'> 1>> : 'T'
            =   <SubstituteNewRestriction 
                    (assign (par s.type t.Name2)((par s.type t.Name1)))
                    t.PRTC
                >;
	(assign (var e.vardata)((par s.type t.Name1)) or ((par s.type t.Name2))) t.PRTC,
        <MyIfNotLess t.Name1 <Add <CurrentIndex 'dpar'<Explode s.type>'_ind'> 1>> : 'T'
            =  <SubstituteNewRestriction 
                    (assign (par s.type t.Name1)((par s.type t.Name2)))
                    t.PRTC
                >;
        (assign (var e.vardata)((par s.type t.Name1)) or ((par s.type t.Name2))) t.PRTC,
        <FreshIndex 'par'<Explode s.type>'_ind'> : t.NewName
            =   <SubstituteNewRestriction (assign (par s.type t.Name1)((par s.type t.NewName))) 
                <SubstituteNewRestriction 
                    (assign (par s.type t.Name2)((par s.type t.NewName)))
                    t.PRTC
                >>;
/*
    3. Подстановка повторна, но новая определяет равенство е-параметра базовому (без вызовов)
   выражению, не содержащему этого параметра - порождаем из подстановки новое сужение. 
*/

	(assign (var e.vardata)((par e e.par)) or (e.Expr)) t.PRTC,
        <IfGround e.Expr> : 'T',
        <FindTerm (par e e.par) e.Expr> : 'F'
            =   <SubstituteNewRestriction 
                    (assign (par e e.par)(e.Expr))
                    t.PRTC
                >;

/* 5. Общий случай - порождаем из повторной подстановки равенство. */
        (assign (t.class e.vardata)(e.Expr1) or (e.Expr2)) t.PRTC 
            =   <PutPRTCNewEq t.PRTC (AreEqual ('F')(e.Expr1) (e.Expr2))>;
}

/*
    (assign (var e.vardata)(e.Expr))(e.assignments) => (assign (var e.vardata)(e.Expr) or (e.Expr2)) |(assign (var e.vardata)(e.Expr))
   Проверяем, уникальна ли вновь найденная подстановка переменной образца.
*/
CheckNewAssignment {
	(assign (t.class e.vardata)(e.Expr))(e.asgs1 (assign (t.class e.vardata)(e.Expr2)) e.asgs2) 
            =   (assign (t.class e.vardata)(e.Expr2) or (e.Expr));
	(assign (t.class e.vardata)(e.Expr))(e.asgs) 
            = (assign (t.class e.vardata)(e.Expr));
}

/*
    Заменяем все вхождения переменных в определение для параметра свежими параметрами.
   Если при этом не появилось новых подстановок переменных - просто подставляем полученное сужение,
   иначе дополнительно подставляем еще и новые подстановки переменных. 
*/

SubstituteNewRestriction {
        (assign t.par ((s.sort s.type t.name))) t.PRTC,
        weval var : e.1 s.sort e.2,
        <LessGenericPattern t.par (s.sort s.type t.name)> : 
        {'F' = <AddAssignments t.PRTC (assign (s.sort s.type t.name)(t.par))>;
         'T',
        <FreshIndex 'par'<Explode s.type>'_ind'> : t.newparname 
            = 
                <SubstituteNewRestrictionAux (assign t.par ((par s.type t.newparname)))
			<AddAssignments t.PRTC (assign (s.sort s.type t.name)((par s.type t.newparname)))> 
                >;
        };
        (assign t.par (e.Val)) t.PRTC,
        <GetPRTCAsgs t.PRTC> : e.Asgs,
        <GenerateNewParameterAssignments (e.Asgs)()<IterateSubstitute (e.Asgs) e.Val>> : 
            {   (e.Asgs)(e.Val) =  
                    <SubstituteNewRestrictionAux (assign t.par (e.Val)) t.PRTC>;
                (e.newasgmnts)(e.NewVal) =
                <SubstituteNewRestrictionAux (assign t.par (e.NewVal))
			<ReplacePRTCAsgs t.PRTC e.newasgmnts> 
                >;    
            };
}

GenerateNewParameterAssignments {
    (e.AsgList)(e.Processed) = (e.AsgList)(e.Processed); 
    (e.AsgList)(e.Processed) t.Var e.Rest,
    e.AsgList : e.1 (assign t.Var (e.Val)) e.2
        = <GenerateNewParameterAssignments (e.AsgList)(e.Processed e.Val) e.Rest>;
    (e.AsgList)(e.Processed) ('*' e.InBr) e.OutBr,
    <GenerateNewParameterAssignments (e.AsgList)()e.InBr> : (e.NewAsgList)(e.InBrResult) 
        = <GenerateNewParameterAssignments (e.NewAsgList)(e.Processed ('*'e.InBrResult))e.OutBr>;
    (e.AsgList)(e.Processed) (call e.call) e.Rest
        = <MSCPError ('A call in parameter assignment: ')((call e.call))>;

    (e.AsgList)(e.Processed) (s.sort s.type t.name) e.Rest,
    weval var : e.1 s.sort e.2,
    (par s.type <FreshIndex 'par'<Explode s.type>'_ind'>) : t.NewPar,
    (assign (s.sort s.type t.name)(t.NewPar)) : t.NewAsg
            = <GenerateNewParameterAssignments (e.AsgList t.NewAsg)(e.Processed t.NewPar) e.Rest>;
    
    (e.AsgList)(e.Processed) t.1 e.1 
        = <GenerateNewParameterAssignments (e.AsgList)(e.Processed t.1) e.1>;
}

/*
    Вспомогательная функция, подставляющая новое сужение во все имеющиеся данные шага прогонки.
   (assign (s.class s.type t.name) (e.Val))[PRTC] => [PRTC] 
*/

SubstituteNewRestrictionAux {
    t.Restrict t.PRTC,
    t.Restrict : (assign t.par (e.Val)),
    <TermContradiction t.par e.Val> :
        {'T' = <NullifyPRTC>;
        'F', <GetPRTCAsgs t.PRTC> : e.Assignments,
            <GetPRTCAllClashes t.PRTC> : e.Clashes 
            =
		<PutPRTCRestr
                <ReplacePRTCClashes
                <ReplacePRTCAsgs 
                    <SubstInAllEqs (t.Restrict) t.PRTC>
                    <Substitute (t.Restrict) e.Assignments>
                >
                <SubstituteInClashes 0 (t.Restrict) e.Clashes>
                >
                t.Restrict
                >;
        };
}

$ENTRY SubstituteInClashes {
/* 1. В обычные сопоставления подстановка сделана, переходим к отложенным. */
	0 (e.Subst)(Delayed e.DelCl) 
            = 
            (Delayed <SubstituteInClashes 1 (e.Subst) e.DelCl>);
/* 2. Подстановка в обычные сопоставления. */
	0 (e.Subst)((e.Expr) to (e.Pattern)) e.Clashes
            = 
		((<Substitute (e.Subst) e.Expr>) to (e.Pattern))
		<SubstituteInClashes 0 (e.Subst) e.Clashes>;
/* 3. Подстановка в отложенные сопоставления (дополнительно вносится информация об изменениях) - УДАЛЕНО!. */
        1 (e.Subst) = ;
	1 (e.Subst)((e.Expr) to (e.Pattern)) e.Clashes,
        <Substitute (e.Subst) e.Expr> : e.Expr1
            = 
            ((e.Expr1) to (e.Pattern))
            <SubstituteInClashes 1 (e.Subst) e.Clashes>;
}

/* Вспомогательная функция, подставляющая выход вызова во все имеющиеся данные шага прогонки. */
SubstituteCallFormat { 
    (assign (call t.fname t.fargs)(e.Val)) t.PRTC,
    <GetPRTCCallRestrs t.PRTC> : e.calls,
    <CheckNewEq4Multiplicity e.calls (AreEqual ('F')((call t.fname t.fargs))(e.Val))> : 
    { (AreEqual e.NewEq) e.CallRestrs   
            = <SubstituteCallFormatAux 
		(assign (call t.fname t.fargs)(e.Val))
		<PutPRTCNewEq <ReplacePRTCCallRestrs t.PRTC e.CallRestrs> (AreEqual e.NewEq)>
            >;
        ()e.CallRestrs 
            = <SubstituteCallFormatAux 
		(assign (call t.fname t.fargs)(e.Val))
		<ReplacePRTCCallRestrs t.PRTC e.CallRestrs>
            >;
    };
}

SubstituteCallFormatAux { 
    (assign (call t.fname t.fargs)(e.Val))t.PRTC,
    <GetPRTCAllClashes t.PRTC> : e.Clashes
        =
        <SubstInNewEqs ((assign (call t.fname t.fargs)(e.Val)))
            <ReplacePRTCClashes t.PRTC
            <SubstituteInClashes 0 ((assign (call t.fname t.fargs)(e.Val))) e.Clashes>
                >
        >;
}


/* Проверка совпадения двух выражений по модулю временных индексов. */
EquivUpToTI {
     = 'T';
    ((call (t.fname t.ti)(args (arg e.Arg)))e.Expr)(call (t.fname t.ti2)(args (arg e.Arg2))e.Expr2)
        = <LogAnd <EquivUpToTI (e.Arg)e.Arg2><EquivUpToTI (e.Expr)e.Expr2>>;
    (('*'e.InBr) e.OutBr)(('*'e.InBr2) e.OutBr2)
        = <LogAnd <EquivUpToTI (e.InBr)e.InBr2><EquivUpToTI (e.OutBr)e.OutBr2>>;
    (t.1 e.Expr)(t.1 e.Expr2)
        = <EquivUpToTI (e.Expr)e.Expr2>;
    (e.X)e.Y = 'F';
}


/*
************************************************************************************
   
                           КОНЕЦ ПРОГОНКИ
   
************************************************************************************
*/



*----------------------------------------------------------------------------------------------------------------------------------


/*
******************************************************************************
   
                 ЗАГЛУШКИ
   
*****************************************************************************
*/


AAA {=; }
